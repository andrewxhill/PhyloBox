/*--------------------------------------------------------------------------.|  Software: PhyloJSON Viewer		                                  		||   Version: 1.0                                                            ||   Contact: sander@digijoi.com || andrewxhill@gmail.com					|                | ------------------------------------------------------------------------- ||     Admin: Andrew Hill (project admininistrator)                          ||   Authors: Sander Pick, Andrew Hill                      			       	|                     | ------------------------------------------------------------------------- ||   License: Distributed under the General Public License (GPL)             ||            http://www.gnu.org/licenses/licenses.html#GPL                  || This program is distributed in the hope that it will be useful - WITHOUT  || ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     || FITNESS FOR A PARTICULAR PURPOSE.                                         |'--------------------------------------------------------------------------*//*######################################################################################################################################## CLASS FRAMEWORK  ###########################################################################*/// Inspired by base2 and Prototype - John Resig    (function(){        var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;        this.Class = function(){};        Class.extend = function(prop) {            var _super = this.prototype;            initializing = true;            var prototype = new this();            initializing = false;            for(var name in prop) {                prototype[name] = typeof prop[name] == "function" &&                typeof _super[name] == "function" && fnTest.test(prop[name]) ?                (function(name, fn){                    return function() {                        var tmp = this._super;                        this._super = _super[name];                        var ret = fn.apply(this, arguments);                               this._super = tmp;                        return ret;                    };                })(name, prop[name]) :                prop[name];            }            function Class() {                if(!initializing && this.init) this.init.apply(this, arguments);            }            Class.prototype = prototype;            Class.constructor = Class;            Class.extend = arguments.callee;            return Class;        };    })();/*############################################################################################################################################### POINT 3D  ###########################################################################*/var Point3D = Class.extend({	// private vars	_fl:2000, _vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _x:0, _y:0, _z:0,	// constructor	init:function(pX,pY,pZ) {		this._x = pX;		this._y = pY;		this._z = pZ;        	},	setVanishingPoint:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;	},	setCenter:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;        // Add click listener here        	},	rotateX:function(angleX) {		// translate		var cosX = Math.cos(angleX);		var sinX = Math.sin(angleX);		var y1 = this._y * cosX - this._z * sinX;		var z1 = this._z * cosX + this._y * sinX;		// update		this._y = y1;		this._z = z1;	},	rotateY:function(angleY) {		// translate		var cosY = Math.cos(angleY);		var sinY = Math.sin(angleY);		var x1 = this._x * cosY - this._z * sinY;		var z1 = this._z * cosY + this._x * sinY;		// update		this._x = x1;		this._z = z1;	},	rotateZ:function(angleZ) {		// translate		var cosZ = Math.cos(angleZ);		var sinZ = Math.sin(angleZ);		var x1 = this._x * cosZ - this._y * sinZ;		var y1 = this._y * cosZ + this._x * sinZ;		// update		this._x = x1;		this._y = y1;	},	// get & set screen position	screenX:function() { return this._vpx + (this._cx + this._x) * (this._fl / (this._fl + this._z + this._cz)); },	screenY:function() { return this._vpy + (this._cy + this._y) * (this._fl / (this._fl + this._z + this._cz)); },	// get & set vars	fl:function(v) { if(v) this._fl = v; else return this._fl; },	x:function(v) { if(v) this._x = v; else return this._x; },	y:function(v) { if(v) this._y = v; else return this._y; },	z:function(v) { if(v) this._z = v; else return this._z; }});/*################################################################################################################################################### LINE  ###########################################################################*/var Dot = Class.extend({	// private vars -- dynamic	// constructor	init:function(pA) {         this._pointA = pA;         /*this._radiusA = rA;*/    },	draw:function(ctx,mode) {		// get color		var lightFactor = this._getLightFactor();		// set styles		ctx.fillStyle = "rgba("+this._color[0]+","+this._color[1]+","+this._color[2]+","+lightFactor+")";		// draw the line		ctx.beginPath();		ctx.arc(this._pointA.screenX(),this._pointA.screenY(),1,0,2*Math.PI,false);		ctx.fill();	},	_getLightFactor:function() {		// generate light factor		return 1;//Math.abs(1 / this.depth())*100;	},	// get & set vars	pointA:function() { return this._pointA; },	//depth:function() { return Math.min(this._pointA.z(),this._pointB.z()); },	color:function(v) { if(v) this._color = v; else return this._color; },});/*################################################################################################################################################### LINE  ###########################################################################*/var Line = Class.extend({	// private vars -- dynamic	// constructor	init:function(pA,pB) {		this._pointA = pA;		this._pointB = pB;	},	draw:function(ctx,mode) {		// get color		var lightFactor = this._getLightFactor();		// set styles		ctx.strokeStyle = "rgba("+this._color[0]+","+this._color[1]+","+this._color[2]+","+lightFactor+")";		// draw the line		ctx.beginPath();		ctx.moveTo(this._pointA.screenX(),this._pointA.screenY());		//ctx.lineTo(this._pointB.screenX(),this._pointB.screenY());		var cpx = this._pointA.screenX();		var cpy = this._pointA.screenY() + (this._pointB.screenY() - this._pointA.screenY());		ctx.quadraticCurveTo(cpx,cpy,this._pointB.screenX(),this._pointB.screenY());		ctx.stroke();	},	_getLightFactor:function() {		// generate light factor		return Math.abs(1 / this.depth())*100;	},	// get & set vars	points:function() { return [ this._pointA, this._pointB ] },	pointA:function() { return this._pointA; },	pointB:function() { return this._pointB; },	depth:function() { return Math.min(this._pointA.z(),this._pointB.z()); },	color:function(v) { if(v) this._color = v; else return this._color; },});/*############################################################################################################################################### SCENE 3D ###########################################################################*/var Scene3D = Class.extend({	// private vars	_vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _dx:0, _dy:0, _dz:0, _ax:0, _ay:0, _az:0, _osc:0,	// constructor	init:function(fr,ctxid,holder,padding,single,full,pW,pH) {        //AWH added ctxid		// setup canvas		this._delay = 1000 / fr;		this._padding = padding;		this._width = (!full) ? pW : $(window).width();		this._height = (!full) ? pH : $(window).height();		this._vpx = this._width / 2;		this._vpy = this._height / 2;		this._cx = 0;		this._cy = 0;		this._holder = holder;        //AWH changed this from random to assigned		this._id = ctxid;		this._single = single;        //AWH removed this, canvas exists		// add to document		//$(this._holder).append("<canvas style='display:none;' width='"+this._width+"' height='"+this._height+"' id='scene-"+this._id+"'></canvas>");		        //AWH changed this to reflect the new canvas id assignment        // get context		this._ctx = $("#"+this._id)[0].getContext('2d');		// window resize on full		var __this = this;		if(full) $(window).bind("resize",function() {			__this._width = $(window).width();			__this._height = $(window).height();			__this._vpx = __this._width / 2;			__this._vpy = __this._height / 2;			$("#scene-"+__this._id).attr({ width:__this._width, height:__this._height });			//if(this._single) { this._update(); this._render(); }		});		// begin		this._renderables = [];		if(!this._single) this._initializeRendering();		// show		$("#scene-"+this._id).fadeIn("slow");	},	addToRenderList:function(objs) {		for(obj in objs) {			objs[obj].setVp(this._vpx,this._vpy);			objs[obj].setCp(this._cx,this._cy,this._cz);			objs[obj].ctx(this._ctx);			this._renderables.push(objs[obj]);		}		if(this._single) { this._update(); this._render(); }	},	removeFromRenderList:function(obj) {		this._renderables.splice(this._renderables.indexOf(obj),1);	},	setVp:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;		// set vanishing point on all targets		for(r in this._renderables) this._renderables[r].setVp(this._vpx, this._vpy);	},	setCp:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;		// set center point on all targets		for(r in this._renderables) this._renderables[r].setCp(this._cx, this._cy, this._cz);	},		_initializeRendering:function() {		// define scope for timer		var __this = this;		// begin frame rendering		this._intID = setInterval(__enterFrameHandler,this._delay);		// define timer handler		function __enterFrameHandler() { __this._update(); __this._render(); };	},	_update:function() {		this._ax = 0.005;		//this._ay = 0.0005;		//this._osc += this._az;		//this._dy = (1/this._ay)*Math.sin(this._osc);		for(r in this._renderables) {			this._renderables[r].setVp(this._vpx, this._vpy);			this._renderables[r].setCp(this._cx, this._cy, this._cz);			this._renderables[r].update({dx:this._dx, dy:this._dy, dz:this._dz, ax:this._ax, ay:this._ay, az:this._az});		}	},	_render:function() {		this._ctx.clearRect(0,0,this._width,this._height);		this._ctx.globalAlpha = 1;		this._ctx.lineWidth = 0.5;		this._ctx.lineJoin = "round";		for(r in this._renderables) this._renderables[r].render();	},	// get & set vars	fr:function(v) {		if(v) {			this._delay = 1000 / v;			clearTimeout(this._intID);			this._initializeRendering();		} else return 1000 / this._delay;	},	vpx:function(v) { if(v) this._vpx = v; else return this._vpx; },	vpy:function(v) { if(v) this._vpy = v; else return this._vpy; },	cx:function(v) { if(v) this._cx = v; else return this._cx; },	cy:function(v) { if(v) this._cy = v; else return this._cy; },	cz:function(v) { if(v) this._cz = v; else return this._cz; },	dx:function(v) { if(v) this._dx = v; else return this._dx; },	dy:function(v) { if(v) this._dy = v; else return this._dy; },	dz:function(v) { if(v) this._dz = v; else return this._dz; },	ax:function(v) { if(v) this._ax = v; else return this._ax; },	ay:function(v) { if(v) this._ay = v; else return this._ay; },	az:function(v) { if(v) this._az = v; else return this._az; },	width:function() { return this._width; },	height:function() { return this._height; }});var Node = Class.extend({	// private vars	_numParents:0, _layer:0, _isLeaf:false, _isRoot:false,	// constructor	init:function(id) { this._id = id; this._children = []; this._siblings = []; this._visible = true; },	addChild:function(v) { this._children.push(v); },	// get & set vars	id:function() { return this._id; },	children:function() { return this._children; },	siblings:function(v) { if(v) this._siblings = v; else return this._siblings; },	numChildren:function() { return this._children.length; },	numSiblings:function() { return this._siblings.length; },	numParents:function(v) { if(v) this._numParents = v; else return this._numParents; },	layer:function(v) { if(v) this._layer = v; else return this._layer; },	isLeaf:function(v) { if(v) this._isLeaf = v; else return this._isLeaf; },	isRoot:function(v) { if(v) this._isRoot = v; else return this._isRoot; },	//–––––––––––––––––––––– for drawing ––––––––––––––––––––––//	// private vars -- none	point3D:function(v) { if(v) this._point3D = v; else return this._point3D; }});var Tree = Class.extend({	// private vars -- dynamic	// constructor	init:function(json,rootId) {		// store original data		this._json = json;		// get node length		this._numNodes = this._json.length;		// clone the original data		this._flat = $.extend(true,{},this._json);		// nest this tree around the root		this._nest(rootId);	},	_nest:function(rootId) {		// define the root node		if(!rootId) rootId = this._flat[0].id;		// get the root json object		var root = $.lookUp(this._flat,"id",rootId);		// exit if invalid		if(!root) { console.log("invalid tree root id"); return false; }		// ensure proper tree direction		if(root.parent_id) {			// if root is leaf, root's parent becomes root			if(!root.children) root = $.lookUp(this._flat,"id",root.parent_id);			// parent -> child			root.children.push({ "id":root.parent_id });			// child -> parent			var parent = $.lookUp(this._flat,"id",root.parent_id);			for(c in parent.children) if(parent.children[c].id==root.id) delete parent.children[c];		}		// make the tree		this._numLeaves = 0;		this._numLayers = 0;		this._nodeList = [];		this._nodes = new Node(rootId);		this._nodes.isRoot(true);		this._branch(this._nodes,root);		for(n in this._nodeList) {			// assign layers			if(this._nodeList[n].isLeaf()) this._nodeList[n].layer(this._numLayers-1);			else this._nodeList[n].layer(this._nodeList[n].numParents());			// assign siblings			for(c in this._nodeList[n].children()) {				var s = this._nodeList[n].children().slice(0);				s.splice(s.indexOf(s[c]),1);				this._nodeList[n].children()[c].siblings(s);			}		}	},	_branch:function(n,d) {		// ensure proper tree direction        for(c in d.children) {            var cd = $.lookUp(this._flat,"id",d.children[c].id);            if(cd.parent_id && cd.parent_id!=d.id) {                // parent -> child                cd.children.push({ "id":cd.parent_id });                // child -> parent                var cpd = $.lookUp(this._flat,"id",cd.parent_id);                for(cc in cpd.children) if(cpd.children[cc].id==cd.id) delete cpd.children[cc];            }        }		// move down tree        //AWH ADDED FOR THE PICKUP OF VISIBILITY CLADE TOGGLE		if(!d.children || !d.visibility) {			n.isLeaf(true);			this._numLeaves++;		} else for(c in d.children) {			var cn = new Node(d.children[c].id);			n.addChild(cn);			//cn.parent(n);			cn.numParents(n.numParents()+1);			this._branch(cn,$.lookUp(this._flat,"id",cn.id()));		}		// max number parents = tree's layer count		if(this._numLayers<=n.numParents()) this._numLayers = n.numParents()+1;		// collect node ref for list		this._nodeList.push(n);	},	nest:function(v) {		// clear from scene		if(this._scene) this._scene.removeFromRenderList(this);		// clone the original data		this._flat = $.extend(true,{},this._json);		// re-nest		this._nest(v); 	},	// get & set vars	nodes:function() { return this._nodes; },	nodeList:function() { return this._nodeList; },	numLayers:function(v) { if(v) this._numLayers = v; else return this._numLayers; },	//–––––––––––––––––––––– for drawing ––––––––––––––––––––––//	// private vars	_osc:0, _changes:{dx:0,dy:0,dz:0,ax:0,ay:0,az:0},	plot:function() {		// refresh data		this._l = [];		this._d = [];		// parse on layer		var nls = [];		for(i=0;i<this._numLayers;i++) nls.push([]);		for(n in this._nodeList) nls[this._nodeList[n].layer()].push(this._nodeList[n]);		nls.reverse();		// calculate coordinates		var gap_x = this._scene.width() / (this._numLayers - 1);		var gap_y = this._scene.height() / (this._numLeaves - 1);		this._max_z = (this._numLayers - 1) * gap_x;		var j = 0;		for(l in nls) {			// sort leaf order			//if(l==this._numLayers-1) { nls[l].sort(function(a,b) { return a.numParents() - b.numParents(); }); }			for(n in nls[l]) {				var x = (nls[l][n].layer() * gap_x) - this._scene.vpx();				if(nls[l][n].isLeaf()) {					var y = (j * gap_y) - this._scene.vpy(); j++;				} else {					nls[l][n].children().sort(function(a,b) { return b.point3D().y() - a.point3D().y(); });					var max_y = nls[l][n].children()[0].point3D().y();					var min_y = nls[l][n].children()[nls[l][n].numChildren()-1].point3D().y();					var y = min_y + ((max_y - min_y) / 2);				}				var z = (nls[l][n].numParents() * gap_x) - (this._max_z / 2);				nls[l][n].point3D(new Point3D(x,y,z));			}		}		// make dots		for(n in this._nodeList) this._d.push(new Dot(this._nodeList[n].point3D()));		// make lines		this._connect(this._nodes);		// display		this._viz();	},	_connect:function(node) {		for(c in node.children()) {			this._l.push(new Line(node.point3D(),node.children()[c].point3D()));			this._connect(node.children()[c]);		}	},	_viz:function() {		this._local = {dx:0,dy:0,dz:0,ax:0,ay:0,az:0};		//this._local = {dx:0,dy:0,dz:0,ax:-Math.PI / 2,ay:Math.PI / 4,az:0};		this._color = [ 255,255,255 ];		// set color		for(d in this._d) this._d[d].color(this._color);		for(l in this._l) this._l[l].color(this._color);		// make local update if present		if(!$.isEmpty(this._local)) this.update(this._local);		// add to scene		this._scene.addToRenderList([this]);		// zoom		this._scene.setCp(this._scene.cx(),this._scene.cy(),this._max_z*2);	},	update:function(v) {		for(d in this._d) {		 	this._d[d].pointA().x(this._d[d].pointA().x()+v.dx+this._changes.dx);		 	this._d[d].pointA().y(this._d[d].pointA().y()+v.dy+this._changes.dy);		 	this._d[d].pointA().z(this._d[d].pointA().z()+v.dz+this._changes.dz);		 	this._d[d].pointA().rotateX(v.ax+this._changes.ax);		 	this._d[d].pointA().rotateY(v.ay+this._changes.ay);		 	this._d[d].pointA().rotateZ(v.az+this._changes.az);		}	},	render:function() {		for(d in this._d) this._d[d].draw(this._ctx);		for(l in this._l) this._l[l].draw(this._ctx);	},	setVp:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;		// set points vanishing point		for(d in this._d) this._d[d].pointA().setVanishingPoint(this._vpx,this._vpy);	},	setCp:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;		// set points center point		for(d in this._d) this._d[d].pointA().setCenter(this._cx,this._cy,this._cz);	},	depth:function() {		var d = new Array();		for(l in this._l) d.push(this._l[l].depth());		return $.arrayMin(d);	},	// get & set vars	scene:function(v) { if(v) this._scene = v; else return this._scene; },	ctx:function(v) { if(v) this._ctx = v; else return this._ctx; },	changes:function(v) { if(v) this._changes = v; else return this._changes; }});/*############################################################################################################################################## DOC READY  ###########################################################################*/function InitDraw(){	//–––––––––––––––––––––––––––––––––––––––––––––––––––––––––– EXTEND UTILS	// on core classes	// ...	// on jquery	$.extend({		lookUp:function(o,p,v) {			// returns false if not unique !			var r; var n = 0;			for(i in o) if(o[i][p]==v) { r = o[i]; n++; }			return (n!=1) ? false : r;		},		makeId:function(l) {		    var text = "";		    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";		    for(i=0; i<l; i++) text += possible.charAt(Math.floor(Math.random()*possible.length));		    return text;		},		isEmpty:function(o) {			var e = true;			for(a in o) e = false;			return e;		},		arrayMin:function(a) {			var min = a[0];			var len = a.length;			for (i=1; i<len; i++) if(a[i]<min) min = a[i];			return min;		},	});	// on jquery objects	$.fn.extend({ });	//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DOC SETUP	// define console to avoid errors when it isn't available	if(!window.console) window.console = { log:function() {} };	//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DOC METHODS	// ...	//–––––––––––––––––––––––––––––––––––––––––––––––––––––––––– INIT OBJECTS	/* get some data if present	$.ajax({		type:"GET",		url:"http://phylobox.appspot.com/api/lookup",		data:"k=tmp-phylobox-1-0-93764e1e-00ba-4c3d-9911-10b2b07ddb64",		//dataType:"json",		complete:function(request) { },		success:function(json) { console.log(json); },		error:function(e) { console.log(e.responseText); }	});*/	// make the scene	var scene = new Scene3D(10,"tree-canvas","body",20,false,true);	// make a tree	//var tree = new Tree(homidae.tree,homidae.root);	//var tree = new Tree(amphibian.tree,amphibian.root);	var tree = new Tree(phylojson.tree,phylojson.root);	var r = phylojson.root;	tree.scene(scene);	tree.plot();		$(window).bind("keydown",function(e) {		if (!e) var e = window.event;		var code = e.keyCode ? e.keyCode : e.which ? e.which : e.charCode;		if(code==40) r++;		else if(code==38) r--;		if(code==40 || code==38) {			tree.nest(r);			tree.plot();		}		return true;	});//####################################################################### END}