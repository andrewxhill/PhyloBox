/*--------------------------------------------------------------------------.|  Software: PhyloBox DRAWING ENGINE                                        ||   Version: 1.0                                                            ||   Contact: andrewxhill@gmail.com || sander@digijoi.com                    || ------------------------------------------------------------------------- ||     Admin: Andrew Hill (project admininistrator)                          ||   Authors: Sander Pick, Andrew Hill                                    	|                     | ------------------------------------------------------------------------- ||   License: Distributed under the General Public License (GPL)             ||            http://www.gnu.org/licenses/licenses.html#GPL                  || This program is distributed in the hope that it will be useful - WITHOUT  || ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     || FITNESS FOR A PARTICULAR PURPOSE.                                         |'--------------------------------------------------------------------------*//*############################################################################################################################################### POINT 3D  ###########################################################################*/var Point3D = Class.extend({	// private vars	_fl:2000, _vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _x:0, _y:0, _z:0, _r:0, _t:0,	// constructor	init:function(pX,pY,pZ,pR,pT) {		this._x = pX;		this._y = pY;		this._z = pZ;		this._r = pR ? pR : 0;		this._t = pT ? pT : 0;	},	setVanishingPoint:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;	},	setCenter:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;	},	rotateX:function(angleX) {		// translate		var cosX = Math.cos(angleX);		var sinX = Math.sin(angleX);		var y1 = this._y * cosX - this._z * sinX;		var z1 = this._z * cosX + this._y * sinX;		// update		this._y = y1;		this._z = z1;	},	rotateY:function(angleY) {		// translate		var cosY = Math.cos(angleY);		var sinY = Math.sin(angleY);		var x1 = this._x * cosY - this._z * sinY;		var z1 = this._z * cosY + this._x * sinY;		// update		this._x = x1;		this._z = z1;	},	rotateZ:function(angleZ) {		// translate		var cosZ = Math.cos(angleZ);		var sinZ = Math.sin(angleZ);		var x1 = this._x * cosZ - this._y * sinZ;		var y1 = this._y * cosZ + this._x * sinZ;		// update		this._x = x1;		this._y = y1;	},	// get & set screen position	screenX:function() { return this._vpx + (this._cx + this._x) * (this._fl / (this._fl + this._z + this._cz)); },	screenY:function() { return this._vpy + (this._cy + this._y) * (this._fl / (this._fl + this._z + this._cz)); },	// get & set vars	fl:function(v) { if(v!==undefined) this._fl = v; else return this._fl; },	x:function(v) { if(v!==undefined) this._x = v; else return this._x; },	y:function(v) { if(v!==undefined) this._y = v; else return this._y; },	z:function(v) { if(v!==undefined) this._z = v; else return this._z; },	r:function(v) { if(v!==undefined) this._r = v; else return this._r; },	t:function(v) { if(v!==undefined) this._t = v; else return this._t; }});/*#################################################################################################################################################### DOT  ###########################################################################*/var Dot = Class.extend({	// private vars	_node:null, _point:null, _view:null,	// constructor	init:function(node,view) {		this._node = node;		this._point = this._node.point3D();		this._view = view;	},	// public methods	draw:function(ctx) {		// check visibility        if(this._node.visibility()) {			// scale radius on depth			var scale = (this._point.z()+3000) / 6000;	        // set styles	        ctx.fillStyle = "#"+this._node.color();			ctx.globalAlpha = scale;	        // draw the line	        ctx.beginPath();			if(scale > 0) ctx.arc(this._point.screenX(),this._point.screenY(),this._view.tree().environment().radius*scale,0,2*Math.PI,false);	        ctx.fill();			// leaf label			if(this._view.tree().environment().leaflabels && this._node.is_leaf()) {				switch(this._view.tree().environment().viewmode) {					case 0 : case 1 :						ctx.textAlign = "left";						var lx = Math.round(this._point.screenX()+5);						var ly = Math.round(this._point.screenY());						break;					case 2 : case 3 :						ctx.textAlign = this._point.t() > Math.PI/2 && this._point.t() < 3*Math.PI/2 ? "right" : "left";						var lx = Math.round(this._point.screenX()+5*Math.cos(this._point.t()));						var ly = Math.round(this._point.screenY()+5*Math.sin(this._point.t()));						break;				}				ctx.textBaseline = "middle";				var label = this._node.name() || this._node.id();				ctx.fillText(label,lx,ly);			}			// htu label			if(this._view.tree().environment().htulabels && this._node.n_children() > 0) {				switch(this._view.tree().environment().viewmode) {					case 0 : case 1 :						ctx.textBaseline = "alphabetic";						ctx.textAlign = "right";						var lx = Math.round(this._point.screenX());						var ly = Math.round(this._point.screenY()-3);						break;					case 2 : case 3 :						ctx.textBaseline = "middle";						ctx.textAlign = this._point.t() > Math.PI/2 && this._point.t() < 3*Math.PI/2 ? "left" : "right";						var lx = Math.round(this._point.screenX()-3*Math.cos(this._point.t()));						var ly = Math.round(this._point.screenY()-3*Math.sin(this._point.t()));						break;				}				var label = this._node.name() || this._node.id();				ctx.fillText(label,lx,ly);			}			// branch label -- coming soon			if(this._view.tree().environment().branchlabels) {  }		}		// selected and hover		if(this._node.selected() && this._node.hover()) {			ctx.strokeStyle = "#00ff00";			ctx.fillStyle = "#D44917";		}		// selected		else if(this._node.selected()) {			ctx.strokeStyle = "#00ff00";			ctx.fillStyle = "#00ff00";		}		// hover		else if(this._node.hover()) {			ctx.strokeStyle = "#D44917";			ctx.fillStyle = "#D44917";		}		// draw highlight		if(this._node.selected() || this._node.hover()) {			ctx.globalAlpha = 1;			ctx.lineWidth = 1;			ctx.dottedArc(this._point.screenX(),this._point.screenY(),10,0,2*Math.PI,false);			ctx.globalAlpha = 0.2;			ctx.beginPath();			ctx.arc(this._point.screenX(),this._point.screenY(),10,0,2*Math.PI,false);			ctx.fill();		}		// set link color		$("div.dot",this._node.link()).css("background","#"+this._node.color());		// set link visibility		if(!this._node.visibility()) $("div.ex",this._node.link()).show();		else $("div.ex",this._node.link()).hide();	},	// get & set vars	point:function() { return this._point; },});/*################################################################################################################################################### LINE  ###########################################################################*/var Line = Class.extend({	// private vars	_node:null, _pointA:null, _pointB:null, _pointC:null, _controlP1:null, _controlP2:null, _view:null,	// constructor	init:function(nodeA,nodeB,siblingP,view) {		this._node = nodeA;		this._pointA = nodeA.point3D();		this._pointB = nodeB.point3D();		this._pointC = siblingP;		this._view = view;		// calculate control points				switch(this._view.tree().environment().viewmode) {			case 0 : case 1 :				if(this._pointC) {					// form the edge vectors					var ab = {};					ab.x = this._pointA.x() - this._pointB.x();					ab.y = this._pointA.y() - this._pointB.y();					ab.z = this._pointA.z() - this._pointB.z();					var bc = {};					bc.x = this._pointB.x() - this._pointC.x();					bc.y = this._pointB.y() - this._pointC.y();					bc.z = this._pointB.z() - this._pointC.z();					// form the normal vector (cross product)					var norm = {};					norm.x = (ab.y * bc.z) - (ab.z * bc.y);					norm.y = -((ab.x * bc.z) - (ab.z * bc.x));					norm.z = (ab.x * bc.y) - (ab.y * bc.x);					// find magnitude of normal vector					var nm = Math.sqrt(norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);					// get the unit normal vector					var un = {};					un.x = norm.x / nm;					un.y = norm.y / nm;					un.z = norm.z / nm;					// define offset for cp1					var off = this._view.gap() * 0.05;					//////////// cp 1					// make 2 points to define a line					var p1 = {};					p1.x = this._pointA.x() + off;					p1.y = this._pointA.y();					p1.z = this._pointC.z();					var p2 = {};					p2.x = p1.x;					p2.y = p1.y;					p2.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v1 = {};					v1.x = this._pointB.x() - p1.x;					v1.y = this._pointB.y() - p1.y;					v1.z = this._pointB.z() - p1.z;					var v2 = {};					v2.x = p2.x - p1.x;					v2.y = p2.y - p1.y;					v2.z = p2.z - p1.z;					// find "slope"					var u1 = (un.x * v1.x + un.y * v1.y + un.z * v1.z) / (un.x * v2.x + un.y * v2.y + un.z * v2.z) || 0;                    // make the control point					var cp1 = {};					cp1.x = p1.x + u1*v2.x;					cp1.y = p1.y + u1*v2.y;					cp1.z = p1.z + u1*v2.z;					this._controlP1 = new Point3D(cp1.x,cp1.y,cp1.z);					//////////// cp 2					// make 2 points to define a line					var p3 = {};					p3.x = p1.x;					p3.y = this._pointB.y();					p3.z = this._pointC.z();					var p4 = {};					p4.x = p1.x;					p4.y = p3.y;					p4.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v3 = {};					v3.x = this._pointB.x() - p3.x;					v3.y = this._pointB.y() - p3.y;					v3.z = this._pointB.z() - p3.z;					var v4 = {};					v4.x = p4.x - p3.x;					v4.y = p4.y - p3.y;					v4.z = p4.z - p3.z;					// find "slope"					var u2 = (un.x * v3.x + un.y * v3.y + un.z * v3.z) / (un.x * v4.x + un.y * v4.y + un.z * v4.z) || 0;                    // make the control point					var cp2 = {};					cp2.x = p3.x + u2*v4.x;					cp2.y = p3.y + u2*v4.y;					cp2.z = p3.z + u2*v4.z;					this._controlP2 = new Point3D(cp2.x,cp2.y,cp2.z);				} else {					this._controlP1 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z());					this._controlP2 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z());				}				break;			case 2 : case 3 :				if(this._pointC) {					// form the edge vectors					var ab = {};					ab.r = this._pointA.r() - this._pointB.r();					ab.t = this._pointA.t() - this._pointB.t();					ab.z = this._pointA.z() - this._pointB.z();					var bc = {};					bc.r = this._pointB.r() - this._pointC.r();					bc.t = this._pointB.t() - this._pointC.t();					bc.z = this._pointB.z() - this._pointC.z();					// form the normal vector (cross product)					var norm = {};					norm.r = (ab.t * bc.z) - (ab.z * bc.t);					norm.t = -((ab.r * bc.z) - (ab.z * bc.r));					norm.z = (ab.r * bc.t) - (ab.t * bc.r);					// find magnitude of normal vector					var nm = Math.sqrt(norm.r * norm.r + norm.t * norm.t + norm.z * norm.z);					// get the unit normal vector					var un = {};					un.r = norm.r / nm;					un.t = norm.t / nm;					un.z = norm.z / nm;					// define offset for cp1					var off = this._view.gap() * 0.05;					//////////// cp 1					// make 2 points to define a line					var p1 = {};					p1.r = this._pointA.r() + off;					p1.t = this._pointA.t();					p1.z = this._pointC.z();					var p2 = {};					p2.r = p1.r;					p2.t = p1.t;					p2.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v1 = {};					v1.r = this._pointB.r() - p1.r;					v1.t = this._pointB.t() - p1.t;					v1.z = this._pointB.z() - p1.z;					var v2 = {};					v2.r = p2.r - p1.r;					v2.t = p2.t - p1.t;					v2.z = p2.z - p1.z;					// find "slope"					var u1 = (un.r * v1.r + un.t * v1.t + un.z * v1.z) / (un.r * v2.r + un.t * v2.t + un.z * v2.z) || 0;					// make the control point					var cp1 = {};					cp1.r = p1.r + u1*v2.r;					cp1.t = p1.t + u1*v2.t;					cp1.z = p1.z + u1*v2.z;					cp1.x = cp1.r * Math.cos(cp1.t) - this._view.cx();					cp1.y = cp1.r * Math.sin(cp1.t) - this._view.cy();					this._controlP1 = new Point3D(cp1.x,cp1.y,cp1.z,cp1.r,cp1.t);					//////////// cp 2					// make 2 points to define a line					var p3 = {};					p3.r = p1.r;					p3.t = this._pointB.t();					p3.z = this._pointC.z();					var p4 = {};					p4.r = p1.r;					p4.t = p3.t;					p4.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v3 = {};					v3.r = this._pointB.r() - p3.r;					v3.t = this._pointB.t() - p3.t;					v3.z = this._pointB.z() - p3.z;					var v4 = {};					v4.r = p4.r - p3.r;					v4.t = p4.t - p3.t;					v4.z = p4.z - p3.z;					// find "slope"					var u2 = (un.r * v3.r + un.t * v3.t + un.z * v3.z) / (un.r * v4.r + un.t * v4.t + un.z * v4.z) || 0;					// make the control point					var cp2 = {};					cp2.r = p3.r + u2*v4.r;					cp2.t = p3.t + u2*v4.t;					cp2.z = p3.z + u2*v4.z;					cp2.x = cp2.r * Math.cos(cp2.t) - this._view.cx();					cp2.y = cp2.r * Math.sin(cp2.t) - this._view.cy();					this._controlP2 = new Point3D(cp2.x,cp2.y,cp2.z,cp2.r,cp2.t);					break;				} else {					this._controlP1 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z(),this._pointA.r(),this._pointA.t());					this._controlP2 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z(),this._pointA.r(),this._pointA.t());				}				break;		}	},	// public methods	draw:function(ctx) {		// check visibility        if(!this._node.visibility()) return false;     	// set styles        ctx.strokeStyle = "#"+this._node.color();	        ctx.globalAlpha = this._getLightFactor();        ctx.lineWidth  = this._view.tree().environment().width;		// draw the line        ctx.beginPath();        ctx.moveTo(this._pointA.screenX(),this._pointA.screenY());		switch(this._view.tree().environment().viewmode) {			case 0 : case 2 : // dendrograms				ctx.lineTo(this._controlP1.screenX(),this._controlP1.screenY());				ctx.lineTo(this._controlP2.screenX(),this._controlP2.screenY());				ctx.lineTo(this._pointB.screenX(),this._pointB.screenY());				break;			case 1 : case 3 :  // cladograms				ctx.lineTo(this._pointB.screenX(),this._pointB.screenY());				break;		}		ctx.stroke();	},	// private methods	_getLightFactor:function() {		// generate light factor		return Math.abs(1 / this.depth())*100;	},	// get & set vars	points:function() { return [ this._pointA, this._pointB ] },	pointA:function() { return this._pointA; },	pointB:function() { return this._pointB; },	controlP1:function() { return this._controlP1; },	controlP2:function() { return this._controlP2; },	depth:function() { return Math.max(Math.min(this._pointA.z(),this._pointB.z()),0.0001); },});/*################################################################################################################################################### VIEW ###########################################################################*/var View = Class.extend({	// private vars	_initialized:false, _tree:null, _delay:50, _holder:"", _padding:null, _single:false, _width:0, _height:0, _ctx:null,	_vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _dx:0, _dy:0, _dz:0, _ax:0, _ay:0, _az:0, _max_z:0, _gap:0, _firstM:{x:0,y:0}, _clicking:false,	_l:[], _d:[], _cp:[],	// constructor	init:function(fr,holder,padding,single,full,pW,pH) {		// save reference		var __this = this;		// setup canvas		this._delay = 1000 / fr;		this._holder = holder;		this._padding = padding;		this._single = single;		this._width = (!full) ? pW : $(this._holder).width() - this._padding.l - this._padding.r;		this._height = (!full) ? pH : $(this._holder).height() - this._padding.t - this._padding.b;		this._vpx = this._width / 2 + (this._padding.l + this._padding.r) / 2;		this._vpy = this._height / 2 + (this._padding.t + this._padding.b) / 2;		this._cx = this._padding.l;		this._cy = this._padding.t;		this._id = "tree-"+$.makeId(8);		// add to document		$(this._holder).append("<canvas style='display:none;' width='"+this._c_width()+"' height='"+this._c_height()+"' id='"+this._id+"'></canvas>");        // get context		this._ctx = $("#"+this._id)[0].getContext('2d');		// window resize on full		if(full) $(document).bind("viewresize",function(e) {			__this._width = $(__this._holder).width() - __this._padding.l - __this._padding.r;			__this._height = $(__this._holder).height() - __this._padding.t - __this._padding.b;			__this._vpx = __this._width / 2 + (__this._padding.l + __this._padding.r) / 2;			__this._vpy = __this._height / 2 + (__this._padding.t + __this._padding.b) / 2;			__this._cx = __this._padding.l;			__this._cy = __this._padding.t;			$("#"+__this._id).attr({ width:__this._c_width(), height:__this._c_height() });			if(__this._single) { __this.plot(); }		});		// hide		$("#"+this._id).hide();	},	// private methods	_initializeRendering:function() {		// define scope for timer		var __this = this;		// begin frame rendering		this._intID = setInterval(__enterFrameHandler,this._delay);		// define timer handler		function __enterFrameHandler() { __this._update(); __this._render(); };	},	_connect:function(node) {        for(var c in node.children()) {			var sp = node.children()[c].siblings().length > 0 ? node.children()[c].siblings()[0].point3D() : false;			var l = new Line(node,node.children()[c],sp,this);			var cp1 = l.controlP1();			var cp2 = l.controlP2();            this._l.push(l);			this._cp.push(cp1);			this._cp.push(cp2);            this._connect(node.children()[c]);        }	},	_viz:function() {		// initialized?		if(!this._initialized) {			this._initialized = true;			// local vars from env			var local = { 				dx:this._tree.environment().offset.dx,				dy:this._tree.environment().offset.dy,				dz:0,				ax:this._tree.environment().offset.ax,				ay:this._tree.environment().offset.ay,				az:this._tree.environment().offset.az			};		}		// zoom		this._cz = this._tree.environment().threeD ? this._tree.environment().offset.dz ? this._tree.environment().offset.dz : this._max_z : 0;		// go		if(local) this._update(local); else this._update();		this._render();	},	_setVp:function() {		// set points vanishing point		for(var d in this._d) this._d[d].point().setVanishingPoint(this._vpx,this._vpy);		// set control points vanishing point		for(var cp in this._cp) this._cp[cp].setVanishingPoint(this._vpx,this._vpy);	},	_setCp:function() {		// set points center point		for(var d in this._d) this._d[d].point().setCenter(this._cx,this._cy,this._cz);		// set control points center point		for(var cp in this._cp) this._cp[cp].setCenter(this._cx,this._cy,this._cz);	},	_update:function(v) {		if(!v) var v = {			dx:this._dx, 			dy:this._dy, 			dz:this._dz, 			ax:this._ax, 			ay:this._ay, 			az:this._az		};		// set vp and cp		this._setVp();		this._setCp();		// update points		for(var d in this._d) {		 	this._d[d].point().x(this._d[d].point().x()+v.dx);		 	this._d[d].point().y(this._d[d].point().y()+v.dy);		 	this._d[d].point().z(this._d[d].point().z()+v.dz);		 	this._d[d].point().rotateX(v.ax);		 	this._d[d].point().rotateY(v.ay);		 	this._d[d].point().rotateZ(v.az);		}		for(var cp in this._cp) {			this._cp[cp].x(this._cp[cp].x()+v.dx);		 	this._cp[cp].y(this._cp[cp].y()+v.dy);		 	this._cp[cp].z(this._cp[cp].z()+v.dz);		 	this._cp[cp].rotateX(v.ax);		 	this._cp[cp].rotateY(v.ay);		 	this._cp[cp].rotateZ(v.az);		}		// 	// store angular velocity		// 	this._renderables[r].environment().angvel.x = this._ax;		// 	this._renderables[r].environment().angvel.y = this._ay;		// 	this._renderables[r].environment().angvel.z = this._az;		// 	// store offsets		// 	this._renderables[r].environment().offset.ax += (this._ax!=0) ? this._ax : 0;		// 	this._renderables[r].environment().offset.ay += (this._ay!=0) ? this._ay : 0;		// 	this._renderables[r].environment().offset.az += (this._az!=0) ? this._az : 0;		// 	this._renderables[r].environment().offset.dx += (this._dx!=0) ? this._dx : 0;		// 	this._renderables[r].environment().offset.dy += (this._dy!=0) ? this._dy : 0;		// 	this._renderables[r].environment().offset.dz = this._cz;	},	_render:function() {		this._ctx.fillStyle = "#"+this._tree.environment().color;		this._ctx.globalAlpha = 1;		this._ctx.fillRect(0,0,this._c_width(),this._c_height());		this._ctx.lineWidth = 1;		this._ctx.lineJoin = "round";		this._ctx.font = "6px Plain";		// 	for(r in this._renderables) this._renderables[r].render(this._viewmode);		// 	// check for click on nodes		// 	if(this._tools.lastM().x && this._tools.lastM().y) {		// 		var xu = this._tools.lastM().x + this._tools.padding();		// 		var xl = this._tools.lastM().x - this._tools.padding();		// 		var yu = this._tools.lastM().y + this._tools.padding();		// 		var yl = this._tools.lastM().y - this._tools.padding();		// 		for(r in this._renderables) {		// 			for(n in this._renderables[r].nodeList()) {		// 				if(this._renderables[r].nodeList()[n].point3D().screenX()<xu 		// 					&& this._renderables[r].nodeList()[n].point3D().screenX()>xl		// 					&& this._renderables[r].nodeList()[n].point3D().screenY()<yu 		// 					&& this._renderables[r].nodeList()[n].point3D().screenY()>yl		// 				) this._tools.currentTool(this._renderables[r].nodeList()[n],this._renderables[r]);		// 			}		// 		}		// 	}		// 	this._tools.lastM().x = null;		// 	this._tools.lastM().y = null;		//  this._tree.environment().viewmode = viewmode;		for(var d in this._d) this._d[d].draw(this._ctx);		for(var l in this._l) this._l[l].draw(this._ctx);		// show center and vanishing point		// this._ctx.fillStyle = "#ff0000";		// this._ctx.globalAlpha = 0.5;		// this._ctx.beginPath();		// this._ctx.arc(this._cx,this._cy,10,0,2*Math.PI,false);		// this._ctx.fill();		// this._ctx.fillStyle = "#00ff00";		// this._ctx.beginPath();		// this._ctx.arc(this._vpx,this._vpy,10,0,2*Math.PI,false);		// this._ctx.fill();	},	// public methods	begin:function() {		// begin		if(!this._single) this._initializeRendering();		// show		$("#"+this._id).fadeIn("slow");	},	refresh:function() {		this._render();	},	plot:function(tree) {		// save tree on first pass		if(tree && !this._tree) this._tree = tree;		// refresh data		this._l = [];		this._d = [];		this._cp = [];		// parse on layer		var nls = [];		for(var i=0;i<this._tree.n_layers();i++) nls.push([]);		for(var n in this._tree.node_list()) nls[this._tree.node_list()[n].layer()].push(this._tree.node_list()[n]);		nls.reverse();		// calculate coordinates		switch(this._tree.environment().viewmode) {			// dendogram, cladogram			case 0 : case 1 :				var gap_x = this._width / (this._tree.n_layers() - 1);				var gap_y = this._height / (this._tree.n_leaves() - 1);				this._max_z = (this._tree.n_layers() - 1) * gap_x;				var j = 0;				for(var l in nls) {					for(var n in nls[l]) {						var x = (nls[l][n].layer() * gap_x) - this._vpx;						if(nls[l][n].is_leaf()) {							var y = j * gap_y - this._vpy; j++;						} else {							var max_y = nls[l][n].children()[0].point3D().y();							var min_y = nls[l][n].children()[nls[l][n].n_children()-1].point3D().y();							var y = min_y + ((max_y - min_y) / 2);						}						var z = this._tree.environment().threeD ? nls[l][n].n_parents() * gap_x - (this._max_z / 2) : 1;                        nls[l][n].point3D(new Point3D(x,y,z));					}				}				this._gap = gap_x;				break;			// circular dendogram, circular cladogram			case 2 : case 3 :				var gap_r = Math.min(this._width,this._height) / (this._tree.n_layers() - 1) / 2;				var gap_t = 2*Math.PI / this._tree.n_leaves();				this._max_z = (this._tree.n_layers() - 1) * gap_r;				var j = 0;				for(var l in nls) {					for(var n in nls[l]) {						var r = nls[l][n].layer() * gap_r;						if(nls[l][n].is_leaf()) {							var t = j * gap_t; j++;							var y = r * Math.sin(t) - this._cy;						} else {							var max_t = nls[l][n].children()[0].point3D().t();							var min_t = nls[l][n].children()[nls[l][n].n_children()-1].point3D().t();							var t = min_t + ((max_t - min_t) / 2);							var y = r * Math.sin(t) - this._cy;						}						var x = r * Math.cos(t) - this._cx;						var z = this._tree.environment().threeD ? nls[l][n].n_parents() * gap_r - (this._max_z / 2) : 1;						nls[l][n].point3D(new Point3D(x,y,z,r,t));					}				}				this._gap = gap_r;				break;			}		// make dots		for(var n in this._tree.node_list()) this._d.push(new Dot(this._tree.node_list()[n],this));		// make lines		this._connect(this._tree.nodes());		// display		this._viz();	},	setVp:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;	},	setCp:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;	},	// get & set vars	_c_width:function() { return this._width+this._padding.l+this._padding.r; },	_c_height:function() { return this._height+this._padding.t+this._padding.b; },	tree:function() { return this._tree; },	holder:function() { return this._holder; },	padding:function() { return this._padding; },	single:function() { return this._single; },	width:function() { return this._width; },	height:function() { return this._height; },	ctx:function() { return this._ctx; },	fr:function(v) {		if(v!==undefined) {			this._delay = 1000 / v;			clearTimeout(this._intID);			this._initializeRendering();		} else return 1000 / this._delay;	},	cx:function(v) { if(v!==undefined) this._cx = v; else return this._cx; },	cy:function(v) { if(v!==undefined) this._cy = v; else return this._cy; },	dx:function(v) { if(v!==undefined) this._dx = v; else return this._dx; },	dy:function(v) { if(v!==undefined) this._dy = v; else return this._dy; },	dz:function(v) { if(v!==undefined) this._dz = v; else return this._dz; },	ax:function(v) { if(v!==undefined) this._ax = v; else return this._ax; },	ay:function(v) { if(v!==undefined) this._ay = v; else return this._ay; },	az:function(v) { if(v!==undefined) this._az = v; else return this._az; },	gap:function() { return this._gap; },});//************ Statc Properties ************//View.DENDROGRAM = 0;//"dendrogram";View.CLADOGRAM = 1;//"smooth dendrogram";View.CIRC_DENDROGRAM = 2;//"cladogram";View.CIRC_CLADOGRAM = 3;//"circular dendrogram";/*############################################################################################################################################## DOC READY  ###########################################################################*/$(function() {	//–––––––––––––––––––––––––––––––––––––––––––––––––––––––––– EXTEND UTILS	// on core classes	CanvasRenderingContext2D.prototype.dottedArc = function(x,y,radius,startAngle,endAngle,anticlockwise) {		var g = Math.PI / radius / 2, sa = startAngle, ea = startAngle + g;		while(ea < endAngle) {			this.beginPath();			this.arc(x,y,radius,sa,ea,anticlockwise);			this.stroke(); 			sa = ea + g;			ea = sa + g;		}	};	// on jquery	$.extend({		makeId:function(l) {		    var text = "";		    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";		    for(i=0; i<l; i++) text += possible.charAt(Math.floor(Math.random()*possible.length));		    return text;		},		arrayMin:function(a) {			var min = a[0];			var len = a.length;			for (i=1; i<len; i++) if(a[i]<min) min = a[i];			return min;		},	});	// on jquery objects	$.fn.extend({ });});//####################################################################### END