/*--------------------------------------------------------------------------.|  Software: PhyloBox DRAWING ENGINE                                        ||   Version: 1.0                                                            ||   Contact: andrewxhill@gmail.com || sander@digijoi.com                    || ------------------------------------------------------------------------- ||     Admin: Andrew Hill (project admininistrator)                          ||   Authors: Sander Pick, Andrew Hill                                    	|                     | ------------------------------------------------------------------------- ||   License: Distributed under the General Public License (GPL)             ||            http://www.gnu.org/licenses/licenses.html#GPL                  || This program is distributed in the hope that it will be useful - WITHOUT  || ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     || FITNESS FOR A PARTICULAR PURPOSE.                                         |'--------------------------------------------------------------------------*//*############################################################################################################################################### POINT 3D###########################################################################*/var Point3D = Class.extend({	// private vars	_fl:2000, _vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _x:0, _y:0, _z:0, _r:0, _t:0,	// constructor	init:function(pX,pY,pZ,pR,pT) {		this._x = pX;		this._y = pY;		this._z = pZ;		this._r = pR ? pR : 0;		this._t = pT ? pT : 0;	},	setVanishingPoint:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;	},	setCenter:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;	},	rotateX:function(angleX) {		// translate		var cosX = Math.cos(angleX);		var sinX = Math.sin(angleX);		var y1 = this._y * cosX - this._z * sinX;		var z1 = this._z * cosX + this._y * sinX;		// update		this._y = y1;		this._z = z1;	},	rotateY:function(angleY) {		// translate		var cosY = Math.cos(angleY);		var sinY = Math.sin(angleY);		var x1 = this._x * cosY - this._z * sinY;		var z1 = this._z * cosY + this._x * sinY;		// update		this._x = x1;		this._z = z1;	},	rotateZ:function(angleZ) {		// translate		var cosZ = Math.cos(angleZ);		var sinZ = Math.sin(angleZ);		var x1 = this._x * cosZ - this._y * sinZ;		var y1 = this._y * cosZ + this._x * sinZ;		// update		this._x = x1;		this._y = y1;	},	// get & set screen position	screenX:function() { return this._vpx + (this._cx + this._x) * (this._fl / (this._fl + this._z + this._cz)); },	screenY:function() { return this._vpy + (this._cy + this._y) * (this._fl / (this._fl + this._z + this._cz)); },	// get & set vars	fl:function(v) { if(v!==undefined) this._fl = v; else return this._fl; },	x:function(v) { if(v!==undefined) this._x = v; else return this._x; },	y:function(v) { if(v!==undefined) this._y = v; else return this._y; },	z:function(v) { if(v!==undefined) this._z = v; else return this._z; },	r:function(v) { if(v!==undefined) this._r = v; else return this._r; },	t:function(v) { if(v!==undefined) this._t = v; else return this._t; }});/*#################################################################################################################################################### DOT###########################################################################*/var Dot = Class.extend({	// private vars	_node:null, _point:null, _view:null,	// constructor	init:function(node,view) {		this._node = node;		this._point = this._node.point3D();		this._view = view;	},	// public methods	draw:function(ctx) {		// check visibility        if(this._node.visibility()) {			// scale radius on depth			var scale = (this._point.z()+3000) / 6000;	        // set styles	        ctx.fillStyle = "#"+this._node.color();			ctx.globalAlpha = scale;	        // draw the line	        ctx.beginPath();			if(scale > 0) ctx.arc(this._point.screenX(),this._point.screenY(),this._view.tree().environment().radius*scale,0,2*Math.PI,false);	        ctx.fill();			// leaf label			if(this._view.tree().environment().leaflabels && this._node.is_leaf()) {				switch(this._view.tree().environment().viewmode) {					case 0 : case 1 :						ctx.textAlign = "left";						var lx = Math.round(this._point.screenX()+5);						var ly = Math.round(this._point.screenY());						break;					case 2 : case 3 :						ctx.textAlign = this._point.t() > Math.PI/2 && this._point.t() < 3*Math.PI/2 ? "right" : "left";						var lx = Math.round(this._point.screenX()+5*Math.cos(this._point.t()));						var ly = Math.round(this._point.screenY()+5*Math.sin(this._point.t()));						break;				}				ctx.textBaseline = "middle";				var label = this._node.name() || this._node.id();				ctx.fillText(label,lx,ly);			}			// htu label			if(this._view.tree().environment().htulabels && this._node.n_children() > 0) {				switch(this._view.tree().environment().viewmode) {					case 0 : case 1 :						ctx.textBaseline = "alphabetic";						ctx.textAlign = "right";						var lx = Math.round(this._point.screenX());						var ly = Math.round(this._point.screenY()-3);						break;					case 2 : case 3 :						ctx.textBaseline = "middle";						ctx.textAlign = this._point.t() > Math.PI/2 && this._point.t() < 3*Math.PI/2 ? "left" : "right";						var lx = Math.round(this._point.screenX()-3*Math.cos(this._point.t()));						var ly = Math.round(this._point.screenY()-3*Math.sin(this._point.t()));						break;				}				var label = this._node.name() || this._node.id();				ctx.fillText(label,lx,ly);			}			// branch label -- coming soon			if(this._view.tree().environment().branchlabels) {  }		}		// selected		if(this._node.selected()) {			ctx.strokeStyle = "#00ff00";			ctx.fillStyle = "#00ff00";			ctx.globalAlpha = 1;			ctx.lineWidth = 1;			ctx.dottedArc(this._point.screenX(),this._point.screenY(),this._view.h_radius(),0,2*Math.PI,false);			ctx.globalAlpha = 0.2;			ctx.beginPath();			ctx.arc(this._point.screenX(),this._point.screenY(),this._view.h_radius(),0,2*Math.PI,false);			ctx.fill();		}		// hover		if(this._node.hover()) {			ctx.strokeStyle = "#ff0000";			ctx.fillStyle = "#ff0000";			ctx.globalAlpha = 1;			ctx.lineWidth = 1;			ctx.dottedArc(this._point.screenX(),this._point.screenY(),this._view.h_radius(),0,2*Math.PI,false);			ctx.globalAlpha = 0.3;			ctx.beginPath();			ctx.arc(this._point.screenX(),this._point.screenY(),this._view.h_radius(),0,2*Math.PI,false);			ctx.fill();		}		// check link		if(!this._view.update_links()) return false;		// set link color		$("div.dot",this._node.link()).css("background","#"+this._node.color());		// set link visibility		if(!this._node.visibility()) $("div.ex",this._node.link()).show();		else $("div.ex",this._node.link()).hide();	},	// get & set vars	point:function() { return this._point; },});/*################################################################################################################################################### LINE###########################################################################*/var Line = Class.extend({	// private vars	_node:null, _pointA:null, _pointB:null, _pointC:null, _controlP1:null, _controlP2:null, _view:null,	// constructor	init:function(nodeA,nodeB,siblingP,view) {		this._node = nodeA;		this._pointA = nodeA.point3D();		this._pointB = nodeB.point3D();		this._pointC = siblingP;		this._view = view;		// calculate control points				switch(this._view.tree().environment().viewmode) {			case 0 : case 1 :				if(this._pointC) {					// form the edge vectors					var ab = {};					ab.x = this._pointA.x() - this._pointB.x();					ab.y = this._pointA.y() - this._pointB.y();					ab.z = this._pointA.z() - this._pointB.z();					var bc = {};					bc.x = this._pointB.x() - this._pointC.x();					bc.y = this._pointB.y() - this._pointC.y();					bc.z = this._pointB.z() - this._pointC.z();					// form the normal vector (cross product)					var norm = {};					norm.x = (ab.y * bc.z) - (ab.z * bc.y);					norm.y = -((ab.x * bc.z) - (ab.z * bc.x));					norm.z = (ab.x * bc.y) - (ab.y * bc.x);					// find magnitude of normal vector					var nm = Math.sqrt(norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);					// get the unit normal vector					var un = {};					un.x = norm.x / nm;					un.y = norm.y / nm;					un.z = norm.z / nm;					// define offset for cp1					var off = this._view.gap() * 0.05;					//////////// cp 1					// make 2 points to define a line					var p1 = {};					p1.x = this._pointA.x() + off;					p1.y = this._pointA.y();					p1.z = this._pointC.z();					var p2 = {};					p2.x = p1.x;					p2.y = p1.y;					p2.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v1 = {};					v1.x = this._pointB.x() - p1.x;					v1.y = this._pointB.y() - p1.y;					v1.z = this._pointB.z() - p1.z;					var v2 = {};					v2.x = p2.x - p1.x;					v2.y = p2.y - p1.y;					v2.z = p2.z - p1.z;					// find "slope"					var u1 = (un.x * v1.x + un.y * v1.y + un.z * v1.z) / (un.x * v2.x + un.y * v2.y + un.z * v2.z) || 0;                    // make the control point					var cp1 = {};					cp1.x = p1.x + u1*v2.x;					cp1.y = p1.y + u1*v2.y;					cp1.z = p1.z + u1*v2.z;					this._controlP1 = new Point3D(cp1.x,cp1.y,cp1.z);					//////////// cp 2					// make 2 points to define a line					var p3 = {};					p3.x = p1.x;					p3.y = this._pointB.y();					p3.z = this._pointC.z();					var p4 = {};					p4.x = p1.x;					p4.y = p3.y;					p4.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v3 = {};					v3.x = this._pointB.x() - p3.x;					v3.y = this._pointB.y() - p3.y;					v3.z = this._pointB.z() - p3.z;					var v4 = {};					v4.x = p4.x - p3.x;					v4.y = p4.y - p3.y;					v4.z = p4.z - p3.z;					// find "slope"					var u2 = (un.x * v3.x + un.y * v3.y + un.z * v3.z) / (un.x * v4.x + un.y * v4.y + un.z * v4.z) || 0;                    // make the control point					var cp2 = {};					cp2.x = p3.x + u2*v4.x;					cp2.y = p3.y + u2*v4.y;					cp2.z = p3.z + u2*v4.z;					this._controlP2 = new Point3D(cp2.x,cp2.y,cp2.z);				} else {					this._controlP1 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z());					this._controlP2 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z());				}				break;			case 2 : case 3 :				if(this._pointC) {					// form the edge vectors					var ab = {};					ab.r = this._pointA.r() - this._pointB.r();					ab.t = this._pointA.t() - this._pointB.t();					ab.z = this._pointA.z() - this._pointB.z();					var bc = {};					bc.r = this._pointB.r() - this._pointC.r();					bc.t = this._pointB.t() - this._pointC.t();					bc.z = this._pointB.z() - this._pointC.z();					// form the normal vector (cross product)					var norm = {};					norm.r = (ab.t * bc.z) - (ab.z * bc.t);					norm.t = -((ab.r * bc.z) - (ab.z * bc.r));					norm.z = (ab.r * bc.t) - (ab.t * bc.r);					// find magnitude of normal vector					var nm = Math.sqrt(norm.r * norm.r + norm.t * norm.t + norm.z * norm.z);					// get the unit normal vector					var un = {};					un.r = norm.r / nm;					un.t = norm.t / nm;					un.z = norm.z / nm;					// define offset for cp1					var off = this._view.gap() * 0.05;					//////////// cp 1					// make 2 points to define a line					var p1 = {};					p1.r = this._pointA.r() + off;					p1.t = this._pointA.t();					p1.z = this._pointC.z();					var p2 = {};					p2.r = p1.r;					p2.t = p1.t;					p2.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v1 = {};					v1.r = this._pointB.r() - p1.r;					v1.t = this._pointB.t() - p1.t;					v1.z = this._pointB.z() - p1.z;					var v2 = {};					v2.r = p2.r - p1.r;					v2.t = p2.t - p1.t;					v2.z = p2.z - p1.z;					// find "slope"					var u1 = (un.r * v1.r + un.t * v1.t + un.z * v1.z) / (un.r * v2.r + un.t * v2.t + un.z * v2.z) || 0;					// make the control point					var cp1 = {};					cp1.r = p1.r + u1*v2.r;					cp1.t = p1.t + u1*v2.t;					cp1.z = p1.z + u1*v2.z;					cp1.x = cp1.r * Math.cos(cp1.t) - this._view.cx();					cp1.y = cp1.r * Math.sin(cp1.t) - this._view.cy();					this._controlP1 = new Point3D(cp1.x,cp1.y,cp1.z,cp1.r,cp1.t);					//////////// cp 2					// make 2 points to define a line					var p3 = {};					p3.r = p1.r;					p3.t = this._pointB.t();					p3.z = this._pointC.z();					var p4 = {};					p4.r = p1.r;					p4.t = p3.t;					p4.z = this._pointA.z();					// make vector to plane and vector to other point on line 					var v3 = {};					v3.r = this._pointB.r() - p3.r;					v3.t = this._pointB.t() - p3.t;					v3.z = this._pointB.z() - p3.z;					var v4 = {};					v4.r = p4.r - p3.r;					v4.t = p4.t - p3.t;					v4.z = p4.z - p3.z;					// find "slope"					var u2 = (un.r * v3.r + un.t * v3.t + un.z * v3.z) / (un.r * v4.r + un.t * v4.t + un.z * v4.z) || 0;					// make the control point					var cp2 = {};					cp2.r = p3.r + u2*v4.r;					cp2.t = p3.t + u2*v4.t;					cp2.z = p3.z + u2*v4.z;					cp2.x = cp2.r * Math.cos(cp2.t) - this._view.cx();					cp2.y = cp2.r * Math.sin(cp2.t) - this._view.cy();					this._controlP2 = new Point3D(cp2.x,cp2.y,cp2.z,cp2.r,cp2.t);					break;				} else {					this._controlP1 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z(),this._pointA.r(),this._pointA.t());					this._controlP2 = new Point3D(this._pointA.x(),this._pointA.y(),this._pointA.z(),this._pointA.r(),this._pointA.t());				}				break;		}	},	// public methods	draw:function(ctx) {		// check visibility        if(!this._node.visibility()) return false;     	// set styles        ctx.strokeStyle = "#"+this._node.color();	        ctx.globalAlpha = this._getLightFactor();        ctx.lineWidth  = this._view.tree().environment().width;		// draw the line        ctx.beginPath();        ctx.moveTo(this._pointA.screenX(),this._pointA.screenY());		switch(this._view.tree().environment().viewmode) {			case 0 : case 2 : // dendrograms				ctx.lineTo(this._controlP1.screenX(),this._controlP1.screenY());				ctx.lineTo(this._controlP2.screenX(),this._controlP2.screenY());				ctx.lineTo(this._pointB.screenX(),this._pointB.screenY());				break;			case 1 : case 3 :  // cladograms				ctx.lineTo(this._pointB.screenX(),this._pointB.screenY());				break;		}		ctx.stroke();	},	// private methods	_getLightFactor:function() {		// generate light factor		return Math.abs(1 / this.depth())*100;	},	// get & set vars	points:function() { return [ this._pointA, this._pointB ] },	pointA:function() { return this._pointA; },	pointB:function() { return this._pointB; },	controlP1:function() { return this._controlP1; },	controlP2:function() { return this._controlP2; },	depth:function() { return Math.max(Math.min(this._pointA.z(),this._pointB.z()),0.0001); },});/*################################################################################################################################################### VIEW###########################################################################*/var View = Class.extend({	// private vars	_inited:false, _id:null, _canvas:null, _tree:null, _delay:50, _holder:null, _padding:null, _single:false, _width:0, _height:0, _int_id:null, _ctx:null,	_vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _dx:0, _dy:0, _dz:0, _ax:0, _ay:0, _az:0, _max_z:0, _gap:0, _h_radius:10,	_fm:{ x:0,y:0 }, _m:{ x:0,y:0 }, _f:{ x:0,y:0,n:null }, _selecting:false, _locked:false, _hovered_node:null, _selected_node:null,	_l:[], _d:[], _cp:[],	_update_links:false, _boundaries:false,	// constructor	init:function(id,holder,padding,single,fr,full,pW,pH) {		// save reference		var __this = this;		// setup canvas		this._delay = 1000 / fr;		this._holder = holder;		this._padding = padding;		this._single = single;		this._width = (!full) ? pW : this._holder.width() - this._padding.l - this._padding.r;		this._height = (!full) ? pH : this._holder.height() - this._padding.t - this._padding.b;		this._id = "view-"+id;		// create canvas		this._canvas = $("<canvas style='display:none;' width='"+this._c_width()+"' height='"+this._c_height()+"' id='"+this._id+"'></canvas>");		// save ref -- sloppy ?		this._canvas.data("view",this);		// add to document		this._canvas.appendTo(this._holder);		// text select tool fix for chrome on mousemove		this._canvas[0].onselectstart = function() { return false; };        // add tool events		this._canvas.bind("pb-select",this._select);		this._canvas.bind("pb-translate",this._translate);		this._canvas.bind("pb-rotate",this._rotate);		this._canvas.bind("pb-zin",this._zin);		this._canvas.bind("pb-zout",this._zout);		// get context		this._ctx = $("#"+this._id)[0].getContext('2d');		// window resize on full		if(full) $(document).bind("pb-treeresize",function(e) {			__this._width = __this._holder.width() - __this._padding.l - __this._padding.r;			__this._height = __this._holder.height() - __this._padding.t - __this._padding.b;			$("#"+__this._id).attr({ width:__this._c_width(), height:__this._c_height() });			if(__this._inited) __this.replot();		});		// hide		$("#"+this._id).hide();		// initialized		this._inited = true;	},	// private methods	_start:function() {		// check single		if(this._single) return false;		// define scope for timer		var __this = this;		// begin frame rendering		this._int_id = setInterval(__enterFrameHandler,this._delay);		// define timer handler		function __enterFrameHandler() { __this._update(); __this._render(); };	},	_stop:function() {		// check single		if(this._single) return false;		// stop time		clearTimeout(this._int_id);	},	_connect:function(node) {        for(var c in node.children()) {			var sp = node.children()[c].siblings().length > 0 ? node.children()[c].siblings()[0].point3D() : false;			var l = new Line(node,node.children()[c],sp,this);			var cp1 = l.controlP1();			var cp2 = l.controlP2();            this._l.push(l);			this._cp.push(cp1);			this._cp.push(cp2);            this._connect(node.children()[c]);        }	},	_update:function() {		// set points vanishing point		for(var d in this._d) this._d[d].point().setVanishingPoint(this._vpx,this._vpy);		// set control points vanishing point		for(var cp in this._cp) this._cp[cp].setVanishingPoint(this._vpx,this._vpy);		// set points center point		for(var d in this._d) this._d[d].point().setCenter(this._cx,this._cy,this._cz);		// set control points center point		for(var cp in this._cp) this._cp[cp].setCenter(this._cx,this._cy,this._cz);		// update points		for(var d in this._d) {		 	this._d[d].point().x(this._d[d].point().x()+this._dx);		 	this._d[d].point().y(this._d[d].point().y()+this._dy);		 	this._d[d].point().z(this._d[d].point().z()+this._dz);		 	this._d[d].point().rotateX(this._ax);		 	this._d[d].point().rotateY(this._ay);		 	this._d[d].point().rotateZ(this._az);		}		for(var cp in this._cp) {			this._cp[cp].x(this._cp[cp].x()+this._dx);		 	this._cp[cp].y(this._cp[cp].y()+this._dy);		 	this._cp[cp].z(this._cp[cp].z()+this._dz);		 	this._cp[cp].rotateX(this._ax);		 	this._cp[cp].rotateY(this._ay);		 	this._cp[cp].rotateZ(this._az);		}		// store offsets		this._tree.environment().offset.ax += this._ax;		this._tree.environment().offset.ay += this._ay;		this._tree.environment().offset.az += this._az;		this._tree.environment().offset.dx += this._dx;		this._tree.environment().offset.dy += this._dy;		this._tree.environment().offset.dz += this._dz;	},	_render:function() {		this._ctx.fillStyle = "#"+this._tree.environment().color;		this._ctx.lineWidth = 1;		this._ctx.font = "6px Plain";		this._ctx.globalAlpha = 1;		this._ctx.fillRect(0,0,this._c_width(),this._c_height());		// draw objects		for(var d in this._d) this._d[d].draw(this._ctx);		for(var l in this._l) this._l[l].draw(this._ctx);		// check locked		if(this._locked) {			// draw lock			this._ctx.strokeStyle = "#ff0000";			this._ctx.globalAlpha = 1;			this._ctx.lineWidth = 1;			this._ctx.dottedArc(this._f.x,this._f.y,this._h_radius,0,2*Math.PI,false);			// draw mouse			this._ctx.fillStyle = "#ff0000";			this._ctx.globalAlpha = 0.3;			this._ctx.beginPath();			this._ctx.arc(this._f.x,this._f.y,this._h_radius,0,2*Math.PI,false);			this._ctx.fill();		}		// check selecting		else if(this._selecting) {			// draw mouse			this._ctx.fillStyle = "#ff0000";			this._ctx.globalAlpha = 0.3;			this._ctx.beginPath();			this._ctx.arc(this._m.x,this._m.y,this._h_radius,0,2*Math.PI,false);			this._ctx.fill();		}		// check boundaries		if(this._boundaries) this._showBounds();		// kill link updates		if(this._update_links) this._update_links = false;	},	_showBounds:function() {		// show padding, center, and vanishing point		this._ctx.strokeStyle = "#00ffff";		this._ctx.fillStyle = "#ff00ff";		this._ctx.lineWidth = 0.5;		this._ctx.globalAlpha = 1;		this._ctx.beginPath();		this._ctx.moveTo(this._cx,this._cy+30);		this._ctx.lineTo(this._cx,this._cy);		this._ctx.lineTo(this._cx+30,this._cy);		this._ctx.moveTo(this._cx+this._width,this._cy+30);		this._ctx.lineTo(this._cx+this._width,this._cy);		this._ctx.lineTo(this._cx+this._width-30,this._cy);		this._ctx.moveTo(this._cx+this._width,this._cy+this._height-30);		this._ctx.lineTo(this._cx+this._width,this._cy+this._height);		this._ctx.lineTo(this._cx+this._width-30,this._cy+this._height);		this._ctx.moveTo(this._cx,this._cy+this._height-30);		this._ctx.lineTo(this._cx,this._cy+this._height);		this._ctx.lineTo(this._cx+30,this._cy+this._height);		this._ctx.stroke();		this._ctx.globalAlpha = 0.5;		this._ctx.beginPath();		this._ctx.moveTo(this._cx+1,this._cy+10);		this._ctx.lineTo(this._cx+1,this._cy+1);		this._ctx.lineTo(this._cx+10,this._cy+1);		this._ctx.fill();		this._ctx.fillStyle = "#ffff00";		this._ctx.beginPath();		this._ctx.arc(this._vpx,this._vpy,5,0,2*Math.PI,false);		this._ctx.fill();	},	// public methods	begin:function() {		// begin		if(!this._single) this._start();		// dispatch ready event and show		$("#"+this._id).trigger("viewready").fadeIn("fast");	},	plot:function(tree) {		// save tree on first pass		if(tree && !this._tree) {			this._tree = tree;			// add the title			this._title = $("<p class='tree-title' id='"+this._id+"-title'>"+this._tree.title()+"</p>");			this._title.appendTo(this._holder);		}		// local offsets		var local = { 			dx:this._tree.environment().offset.dx,			dy:this._tree.environment().offset.dy,			dz:this._tree.environment().offset.dz,			ax:this._tree.environment().offset.ax,			ay:this._tree.environment().offset.ay,			az:this._tree.environment().offset.az		};		// position vanishing point		this._vpx = this._width / 2 + (this._padding.l + this._padding.r) / 2 + local.dx;		this._vpy = this._height / 2 + (this._padding.t + this._padding.b) / 2 + local.dy;		this._cx = this._padding.l;		this._cy = this._padding.t;		// refresh data		this._l = [];		this._d = [];		this._cp = [];		// parse on layer		var nls = [];		for(var i=0;i<this._tree.n_layers();i++) nls.push([]);		for(var n in this._tree.node_list()) nls[this._tree.node_list()[n].layer()].push(this._tree.node_list()[n]);		nls.reverse();		// calculate coordinates		switch(this._tree.environment().viewmode) {			// dendogram, cladogram			case 0 : case 1 :				var gap_x = this._width / (this._tree.n_layers() - 1);				var gap_y = this._height / (this._tree.n_leaves() - 1);				this._max_z = (this._tree.n_layers() - 1) * gap_x;				var j = 0;				for(var l in nls) {					for(var n in nls[l]) {						var x = (nls[l][n].layer() * gap_x) - this._vpx;						if(nls[l][n].is_leaf()) {							var y = j * gap_y - this._vpy; j++;						} else {							var max_y = nls[l][n].children()[0].point3D().y();							var min_y = nls[l][n].children()[nls[l][n].n_children()-1].point3D().y();							var y = min_y + ((max_y - min_y) / 2);						}						var z = this._tree.environment().threeD ? nls[l][n].n_parents() * gap_x - (this._max_z / 2) : 1;                        nls[l][n].point3D(new Point3D(x,y,z));					}				}				this._gap = gap_x;				break;			// circular dendogram, circular cladogram			case 2 : case 3 :				var gap_r = Math.min(this._width,this._height) / (this._tree.n_layers() - 1) / 2;				var gap_t = 2*Math.PI / this._tree.n_leaves();				this._max_z = (this._tree.n_layers() - 1) * gap_r;				var j = 0;				for(var l in nls) {					for(var n in nls[l]) {						var r = nls[l][n].layer() * gap_r;						if(nls[l][n].is_leaf()) {							var t = j * gap_t; j++;							var y = r * Math.sin(t) - this._cy;						} else {							var max_t = nls[l][n].children()[0].point3D().t();							var min_t = nls[l][n].children()[nls[l][n].n_children()-1].point3D().t();							var t = min_t + ((max_t - min_t) / 2);							var y = r * Math.sin(t) - this._cy;						}						var x = r * Math.cos(t) - this._cx;						var z = this._tree.environment().threeD ? nls[l][n].n_parents() * gap_r - (this._max_z / 2) : 1;						nls[l][n].point3D(new Point3D(x,y,z,r,t));					}				}				this._gap = gap_r;				break;			}		// make dots		for(var n in this._tree.node_list()) this._d.push(new Dot(this._tree.node_list()[n],this));		// make lines		this._connect(this._tree.nodes());		// set points vanishing point		for(var d in this._d) this._d[d].point().setVanishingPoint(this._vpx,this._vpy);		// set control points vanishing point		for(var cp in this._cp) this._cp[cp].setVanishingPoint(this._vpx,this._vpy);		// zoom		this._cz = this._tree.environment().threeD ? this._max_z : 0;		// set points center point		for(var d in this._d) this._d[d].point().setCenter(this._cx,this._cy,this._cz);		// set control points center point		for(var cp in this._cp) this._cp[cp].setCenter(this._cx,this._cy,this._cz);		// update points		for(var d in this._d) {		 	this._d[d].point().x(this._d[d].point().x()+local.dx);		 	this._d[d].point().y(this._d[d].point().y()+local.dy);		 	this._d[d].point().z(this._d[d].point().z()+local.dz);		 	this._d[d].point().rotateX(local.ax);		 	this._d[d].point().rotateY(local.ay);		 	this._d[d].point().rotateZ(local.az);		}		for(var cp in this._cp) {			this._cp[cp].x(this._cp[cp].x()+local.dx);		 	this._cp[cp].y(this._cp[cp].y()+local.dy);		 	this._cp[cp].z(this._cp[cp].z()+local.dz);		 	this._cp[cp].rotateX(local.ax);		 	this._cp[cp].rotateY(local.ay);		 	this._cp[cp].rotateZ(local.az);		}		// first render		this._ctx.fillStyle = "#"+this._tree.environment().color;		this._ctx.lineWidth = 1;		this._ctx.font = "6px Plain";		this._ctx.globalAlpha = 1;		this._ctx.fillRect(0,0,this._c_width(),this._c_height());		// add to link style		this._update_links = true;		// draw objects		for(var d in this._d) this._d[d].draw(this._ctx);		for(var l in this._l) this._l[l].draw(this._ctx);		// check boundaries		if(this._boundaries) this._showBounds();		// update and position title		this._title.text(this._tree.title()).css({ bottom:0,right:0 });	},	replot:function() {		// pause time		this._stop();		// calcs		this.plot();		// go		this._start();	},	refresh:function() {		// check single		if(this._single) this._render();	},	setVp:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;	},	setCp:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;	},	setSelected:function(n) {		// set		n.selected(true);		this._selected_node = n;	},	clearSelected:function() {		// clear		if(this._selected_node) this._selected_node.selected(false);	},	// tools	_select:function(e,t,m) {		// get ref		var __this = $(e.target).data("view");		// determine action		switch(t) {			case "mousedown" :				// set				__this._m = m;				__this._selecting = true;				// search for nearby nodes				var nodes = __this.tree().node_list(),					r = __this._h_radius;				for(var n in nodes) {					var p = {}; 					p.x = nodes[n].point3D().screenX(),					p.y = nodes[n].point3D().screenY();					if(m.x + r >= p.x && m.x - r <= p.x && m.y + r >= p.y && m.y - r <= p.y) {						__this._f.x = p.x;						__this._f.y = p.y;						PhyloBox.Interface.setNode(nodes[n],true);						__this._locked = true;						break;					}				}				// draw				__this._render();				// clear				__this._selecting = false;				__this._locked = false;				break;			case "mousesearch" :				// set				__this._m = m;				__this._selecting = true;				PhyloBox.Interface.unhoverNode(__this._hovered_node);				// search for nearby nodes				var nodes = __this.tree().node_list(),					r = __this._h_radius;				for(var n in nodes) {					var p = {}; 					p.x = nodes[n].point3D().screenX(),					p.y = nodes[n].point3D().screenY();					if(m.x + r >= p.x && m.x - r <= p.x && m.y + r >= p.y && m.y - r <= p.y) {						__this._f.x = p.x;						__this._f.y = p.y;						__this._locked = true;						__this._hovered_node = nodes[n];						PhyloBox.Interface.hoverNode(__this._hovered_node);						break;					}				}				// draw				__this._render();				// clear				__this._selecting = false;				__this._locked = false;				break;		}	},	_translate:function(e,t,m) {		// get ref		var __this = $(e.target).data("view");		// determine action		switch(t) {			case "mousedown" :				// save mouse				__this._fm = m;				break;			case "mousemove" :				// set				__this._dx = m.x - __this._fm.x;				__this._dy = m.y - __this._fm.y;				__this._vpx += __this._dx;				__this._vpy += __this._dy;				// draw				__this._update(); __this._render();				// clear				__this._fm = m;				__this._dx = __this._dy = 0;				break;		}	},	_rotate:function(e,t,m) {		// get ref		var __this = $(e.target).data("view");		// determine action		switch(t) {			case "mousedown" :				// save mouse				__this._fm = m;				break;			case "mousemove" :				switch(__this._tree.environment().threeD) {					// 2D					case false :						// direction						var sx = m.x - __this._fm.x,							sy = m.y - __this._fm.y;						// displacement						var	asx = Math.abs(sx),							asy = Math.abs(sy);						// unit direction						var drx = sx / asx || 1,							dry = sy / asy || 1;						// quadrant						if(m.x < __this._vpx) dry *= -1;						if(m.y > __this._vpy) drx *= -1;						// choose						var dr = asx > asy ? drx : dry;						// set						__this._az = dr * Math.sqrt(asx * asx + asy * asy) / 100;						// draw						__this._update(); __this._render();						// clear						__this._fm = m;						__this._az = 0;						break;					// 3D					case true :						// set						__this._ax = (m.y - __this._fm.y) / 100;						__this._ay = (m.x - __this._fm.x) / 100;						// draw						__this._update(); __this._render();						// clear						__this._fm = m;						__this._ax = __this._ay = 0;						break;				}				break;		}	},	_zin:function(e,t,m) { console.log(t+" by zoom in at "+m.x+", "+m.y); },	_zout:function(e,t,m) { console.log(t+" by zoom out at "+m.x+", "+m.y); },	// get & set vars	_c_width:function() { return this._width+this._padding.l+this._padding.r; },	_c_height:function() { return this._height+this._padding.t+this._padding.b; },	id:function() { return this._id; },	tree:function() { return this._tree; },	holder:function() { return this._holder; },	padding:function() { return this._padding; },	single:function() { return this._single; },	width:function() { return this._width; },	height:function() { return this._height; },	ctx:function() { return this._ctx; },	fr:function(v) {		if(v!==undefined) {			this._delay = 1000 / v;			this._stop();			this._start();		} else return 1000 / this._delay;	},	cx:function(v) { if(v!==undefined) this._cx = v; else return this._cx; },	cy:function(v) { if(v!==undefined) this._cy = v; else return this._cy; },	dx:function(v) { if(v!==undefined) this._dx = v; else return this._dx; },	dy:function(v) { if(v!==undefined) this._dy = v; else return this._dy; },	dz:function(v) { if(v!==undefined) this._dz = v; else return this._dz; },	ax:function(v) { if(v!==undefined) this._ax = v; else return this._ax; },	ay:function(v) { if(v!==undefined) this._ay = v; else return this._ay; },	az:function(v) { if(v!==undefined) this._az = v; else return this._az; },	gap:function() { return this._gap; },	h_radius:function(v) { if(v!==undefined) this._h_radius = v; else return this._h_radius; },	selecting:function(v) { if(v!==undefined) this._selecting = v; else return this._selecting; },	hovered_node:function(v) { if(v!==undefined) this._hovered_node = v; else return this._hovered_node; },	selected_node:function(v) { if(v!==undefined) this._selected_node = v; else return this._selected_node; },	update_links:function(v) { if(v!==undefined) this._update_links = v; else return this._update_links; },	boundaries:function(v) { if(v!==undefined) this._boundaries = v; else return this._boundaries; },});//************ Statc Properties ************//View.DENDROGRAM = 0;//"dendrogram";View.CLADOGRAM = 1;//"smooth dendrogram";View.CIRC_DENDROGRAM = 2;//"cladogram";View.CIRC_CLADOGRAM = 3;//"circular dendrogram";/*############################################################################################################################################## DOC READY###########################################################################*/$(function() {	//–––––––––––––––––––––––––––––––––––––––––––––––––––––––––– EXTEND UTILS	// on core classes	CanvasRenderingContext2D.prototype.dottedArc = function(x,y,radius,startAngle,endAngle,anticlockwise) {		var g = Math.PI / radius / 2, sa = startAngle, ea = startAngle + g;		while(ea < endAngle) {			this.beginPath();			this.arc(x,y,radius,sa,ea,anticlockwise);			this.stroke(); 			sa = ea + g;			ea = sa + g;		}	};	// on jquery	$.extend({		makeId:function(l) {		    var text = "";		    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";		    for(i=0; i<l; i++) text += possible.charAt(Math.floor(Math.random()*possible.length));		    return text;		},		arrayMin:function(a) {			var min = a[0];			var len = a.length;			for (i=1; i<len; i++) if(a[i]<min) min = a[i];			return min;		},	});	// on jquery objects	$.fn.extend({ });});//####################################################################### END