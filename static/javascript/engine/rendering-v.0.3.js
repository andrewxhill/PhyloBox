/*--------------------------------------------------------------------------.|  Software: PhyloJSON Viewer		                                  		||   Version: 0.2                                                            ||   Contact: sander@digijoi.com || andrewxhill@gmail.com					|                | ------------------------------------------------------------------------- ||     Admin: Andrew Hill (project admininistrator)                          ||   Authors: Sander Pick, Andrew Hill                      			       	|                     | ------------------------------------------------------------------------- ||   License: Distributed under the General Public License (GPL)             ||            http://www.gnu.org/licenses/licenses.html#GPL                  || This program is distributed in the hope that it will be useful - WITHOUT  || ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or     || FITNESS FOR A PARTICULAR PURPOSE.                                         |'--------------------------------------------------------------------------*//*######################################################################################################################################## CLASS FRAMEWORK  ###########################################################################*/// Inspired by base2 and Prototype - John Resig(function() {	var initializing = false, fnTest = /xyz/.test(function(){xyz;}) ? /\b_super\b/ : /.*/;	this.Class = function(){};	Class.extend = function(prop) {    	var _super = this.prototype;    	initializing = true;    	var prototype = new this();    	initializing = false;    	for(var name in prop) {      		prototype[name] = typeof prop[name] == "function" &&        	typeof _super[name] == "function" && fnTest.test(prop[name]) ?        	(function(name, fn){          		return function() {            		var tmp = this._super;            		this._super = _super[name];            		var ret = fn.apply(this, arguments);                   		this._super = tmp;            		return ret;          		};        	})(name, prop[name]) :        	prop[name];    	}		function Class() {      		if(!initializing && this.init) this.init.apply(this, arguments);    	}    	Class.prototype = prototype;    	Class.constructor = Class;    	Class.extend = arguments.callee;    	return Class;	};})();/*############################################################################################################################################# TREE TOOLS###########################################################################*/var TreeTools = Class.extend({ // Scene carries instances of this Class	// private vars    // lastX,lastY are click location, (firstX,firstY can be used later to reconstruct movement)     _cid:null, _firstM:{x:null,y:null}, _lastM:{x:null,y:null}, _padding:4, // padding is clickable area radius    // constructor 	init:function(cid) {    	this._cid = cid;		// hold a reference to the current tool // *** SWP		this._currentTool = this.changeRoot; // externalLink is the default        $("#edit_tools #handTool img").css('border-bottom','2px solid grey');        		var __this = this;		// set up a click listener on the canvas    	$("#"+this._cid).mousedown(function(e) {        	var position = $(this).position();        	__this._firstM.x = e.pageX-position.left;        	__this._firstM.y = e.pageY-position.top;     	});    	// set up a click listener on the canvas    	$("#"+this._cid).mouseup(function(e) {        	var position = $(this).position();            __this._lastM.x = e.pageX-position.left;            __this._lastM.y = e.pageY-position.top;         });                $('#edit_tools .tool').click(function() {        $('.tool img').css('border','0px');            $(this).children('img').css('border-bottom','2px solid grey');            var tool = this.id;            // calculate coordinates            switch(tool) {                case "handTool" : default :                    __this._currentTool = __this.handTool;                    break;                case "toggleClade" :                    __this._currentTool = __this.toggleClade;                    break;                case "editMetadata" :                     __this._currentTool = __this.editMetadata;                    break;                case "paintNodes" :                     __this._currentTool = __this.paintNodes;                    break;                case "externalLink" :                    __this._currentTool = __this.externalLink;                    break;                case "changeRoot" :                    __this._currentTool = __this.changeRoot;                    break;            }        });    },    handTool:function(node) {		console.log("The hand tool is manipulating node #"+node.id()+" !");        // the real hand tool should be defined elsewhere,        // but we can still include it here so errors aren't passed        // if the handtool is selected        return true;    },    toggleClade:function(node) {		//console.log("The toggle tool is manipulating node #"+node.id()+" !");        if(!node.isLeaf()){            var vis;            (!node.children()[0].visibility()) ? vis=true : vis=false;            function walkTree(n,vis){                for (var c in n.children()) {                    child = n.children()[c];                    child.visibility(vis);                    walkTree(child,vis);                }            }            walkTree(node,vis);        }    },    editMetadata:function(node) {		console.log("The hand tool is manipulating node #"+node.id()+" !");    },    paintNodes:function(node) {        var color = $('#colornode').val();        node.color(color);        //also change the color of the node in our taxalist        $("li#"+node.id()).css("color","#"+color);        function paintCascade(node) {            if (node.children()) {                for (var i in node.children()) {                    var child = node.children()[i];                    child.color(color);                    $("li#"+child.id()).css("color","#"+color);                    paintCascade(child);                }            }        }        paintCascade(node);    },    externalLink:function(node) { // **** SWP modified this, i think this is the intended function, but double check... i was getting syntax errors        // get the primaryuri value, not sure where this will be in the future        var type = $('#primaryURI').val();        if(node.uri()){            if(node.uri()[type]) {                // alert(Nodes[nodeId]['uri'][uri]);                window.open(node.uri()[type],'_blank');            }        }	},    changeRoot:function(node,tree) { // **** SWP modified this, i think this is the intended function, but double check... i was getting syntax errors        console.log(node.id());        //tree.nest(node.id());        //tree.plot(Tree.DENDROGRAM);    },	currentTool:function(v,t) { (this._currentTool)(v,t); }, // **** SWP calls the current tool function	// get and set vars	firstM:function() { return this._firstM; },	lastM:function() { return this._lastM; },	padding:function() { return this._padding; },});/*############################################################################################################################################# ENV TOOLS###########################################################################*/var EnvTools = Class.extend({ // Tree carries instances of this Class	// private vars    _env:null,    // how to change the tree.title variable?	// constructor	init:function(env) {        this._env = env;		var __this = this;        //set listener for background color        $('#background_color').change(function() {        	__this._env.color = $(this).val(); // **** SWP changes this and others like it (this._env is a regular object)            //console.log($(this).val());        });        // set listener for bwidth, see imported jquery ui libraries        // needs a few of them in the head of any current phylobox viewer page        // will create a envtools-min.js for the widget so that we don't get        // errors for not loading those libraries        //$(function() { // SWP <<--------------------------- I dont think you need to do this ... any instance of this class will be created after InitDraw, which should only run after doc ready.        //<<<<<<<<<<<<<<<<<<<<<<<<<<<<======== comment for SWP development ========// ( slider is not defined on my system... )		        //viewtype toggle selector        if(!__this._env.viewmode){__this._env.viewmode='dendrogram'};        $("#view_selector").buttonset();        $("#view_selector #"+__this._env.viewmode).attr('select',true);        $('#view_selector :radio').click(function(){            __this._env.viewmode = this.id;        });                $('.branch_width_slider').slider({             value:__this._env.width,            min:1,            max:10,            step:1,            slide:function(event,ui) {                $('#branch_width').html(ui.value);                __this._env.width = ui.value;            }        });        //});        // set up Node Radius Slider        //$(function() {        $('.node_radius_slider').slider({	            value:__this._env.radius,            min:0,            max:10,            step:1,            slide:function(event,ui) {                $('#node_radius').html(ui.value);                __this._env.radius = ui.value;            }        });		//======== for SWP development ========>>>>>>>>>>>>>>>>>>>>>>>>>//        //});        // track primaryURI changes        $('#primary_uri').change(function() {            var tmp =  $(this).val();            __this._env.primaryuri = (tmp!='none') ? tmp : null;        });        // track viewtype changes        $('#view_type').change(function() {            __this._env.viewtype = $(this).val();        });    }});/*############################################################################################################################################### POINT 3D  ###########################################################################*/var Point3D = Class.extend({	// private vars	_fl:2000, _vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _x:0, _y:0, _z:0,	// constructor	init:function(pX,pY,pZ) {		this._x = pX;		this._y = pY;		this._z = pZ;	},	setVanishingPoint:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;	},	setCenter:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;	},	rotateX:function(angleX) {		// translate		var cosX = Math.cos(angleX);		var sinX = Math.sin(angleX);		var y1 = this._y * cosX - this._z * sinX;		var z1 = this._z * cosX + this._y * sinX;		// update		this._y = y1;		this._z = z1;	},	rotateY:function(angleY) {		// translate		var cosY = Math.cos(angleY);		var sinY = Math.sin(angleY);		var x1 = this._x * cosY - this._z * sinY;		var z1 = this._z * cosY + this._x * sinY;		// update		this._x = x1;		this._z = z1;	},	rotateZ:function(angleZ) {		// translate		var cosZ = Math.cos(angleZ);		var sinZ = Math.sin(angleZ);		var x1 = this._x * cosZ - this._y * sinZ;		var y1 = this._y * cosZ + this._x * sinZ;		// update		this._x = x1;		this._y = y1;	},	// get & set screen position	screenX:function() { return this._vpx + (this._cx + this._x) * (this._fl / (this._fl + this._z + this._cz)); },	screenY:function() { return this._vpy + (this._cy + this._y) * (this._fl / (this._fl + this._z + this._cz)); },	// get & set vars	fl:function(v) { if(v) this._fl = v; else return this._fl; },	x:function(v) { if(v) this._x = v; else return this._x; },	y:function(v) { if(v) this._y = v; else return this._y; },	z:function(v) { if(v) this._z = v; else return this._z; },	r:function() { return Math.sqrt((this._x * this._x) + (this._y * this._y)); },	t:function() { return Math.atan(this._y / this._x); }});/*############################################################################################################################################ Node Lable  ###########################################################################*/var NodeLabel = Class.extend({	// private vars -- dynamic	// constructor    //AWH added, meant to add labels to the tree. should be controlled by the nodelabels toggle	init:function(pA,label,node) {		this._pointA = pA;         this._label = label;        this._node = node;        this._isLeaf = node.isLeaf();        this._color = "F0F0F0";	},	draw:function(ctx,mode) {        if (this._node.visibility()){            var lightFactor = this._getLightFactor();            ctx.beginPath();            ctx.fillStyle = "#"+_this._color;            ctx.globalAlpha = lightFactor;            ctx.fillText(this._label,this._pointA.screenX()+10,this._pointA.screenY()+10);            ctx.fill();                    }	},	_getLightFactor:function() {		// generate light factor		return 1;//Math.abs(1 / this.depth())*100;	},	// get & set vars	pointA:function() { return this._pointA; },	//depth:function() { return Math.min(this._pointA.z(),this._pointB.z()); },	color:function(v) { if(v) this._color = v; else return this._color; },	label:function(v) { if(v) this._color = v; else return this._color; },});/*############################################################################################################################################ Branch Lable  ###########################################################################*/var BranchLabel = Class.extend({	// private vars -- dynamic	// constructor    //AWH added, meant to add branch labels to the tree. should be controlled by the branchlabels toggle	init:function(pA,label,node) {		this._pointA = pA;         this._label = label;        this._node = node;        this._isLeaf = node.isLeaf();        this._color = "F0F0F0";	},	draw:function(ctx,mode) {        if (this._node.visibility()){            var lightFactor = this._getLightFactor();            ctx.beginPath();            ctx.fillStyle = "#"+_this._color;            ctx.globalAlpha = lightFactor;            ctx.fillText(this._label,this._pointA.screenX()+10,this._pointA.screenY()+10);            ctx.fill();                    }	},	_getLightFactor:function() {		// generate light factor		return 1;//Math.abs(1 / this.depth())*100;	},	// get & set vars	pointA:function() { return this._pointA; },	//depth:function() { return Math.min(this._pointA.z(),this._pointB.z()); },	color:function(v) { if(v) this._color = v; else return this._color; },	label:function(v) { if(v) this._color = v; else return this._color; },});/*################################################################################################################################################## DOT  ###########################################################################*/var Dot = Class.extend({	// private vars -- dynamic	// constructor	init:function(pA,node,env) {		this._pointA = pA;         this._env = env;        this._node = node; //this will auto update if we send the Dot( the whole node		/*this._radiusA = pR;*/ // **** AWH added radius	},	draw:function(ctx,mode) {        if (this._node.visibility()){            //this._pointA.z()            var radmod = Math.abs((this._pointA.z()+4000)/8000);            //console.log(this._pointA);            // get color            var lightFactor = this._getLightFactor();            // set styles            //ctx.fillStyle = "rgba("+this._color[0]+","+this._color[1]+","+this._color[2]+","+lightFactor+")";                        ctx.fillStyle = "#"+this._node.color();            ctx.globalAlpha = lightFactor;            // draw the line            ctx.beginPath();            ctx.arc(this._pointA.screenX(),this._pointA.screenY(),(this._env.radius*radmod),0,2*Math.PI,false);            ctx.fill();        }	},	_getLightFactor:function() {		// generate light factor		return 1;//Math.abs(1 / this.depth())*100;	},	// get & set vars	pointA:function() { return this._pointA; },	//depth:function() { return Math.min(this._pointA.z(),this._pointB.z()); },	color:function(v) { if(v) this._color = v; else return this._color; },});/*################################################################################################################################################### LINE  ###########################################################################*/var Line = Class.extend({	// private vars -- dynamic	// constructor	init:function(pA,pB,node,env) { //awh bring in the environment for the width/shape		this._pointA = pA;		this._pointB = node.point3D();        //color is defined by the child        this._node = node;                this._env = env;	},	draw:function(ctx,mode) {        if(this._node.visibility()){            // get color            var lightFactor = this._getLightFactor();            // set styles            //ctx.strokeStyle = "rgba("+this._color[0]+","+this._color[1]+","+this._color[2]+","+lightFactor+")";            ctx.strokeStyle = "#"+this._node.color();            ctx.globalAlpha = lightFactor;                        // draw the line            // AWH added line width            var radmod = Math.abs((this._pointB.z()+4000)/8000);            ctx.lineWidth  = this._env.width*radmod;                        ctx.beginPath();            ctx.moveTo(this._pointA.screenX(),this._pointA.screenY());            //ctx.lineTo(this._pointB.screenX(),this._pointB.screenY());            var cpx = this._pointA.screenX();            var cpy = this._pointA.screenY() + (this._pointB.screenY() - this._pointA.screenY());            var mode = 0;            if (!mode) {                ctx.quadraticCurveTo(cpx,cpy,this._pointB.screenX(),this._pointB.screenY());            } else {                                ctx.moveTo(this._pointB.screenX(), this._pointB.screenY());                ctx.lineTo(this._pointB.screenX(), this._pointA.screenY()-this._pointA.screenY()+0.9*(this._pointA.screenY()-this._pointB.screenY()));                ctx.moveTo(this._pointB.screenX(), this._pointA.screenY()-this._pointA.screenY()+0.9*(this._pointA.screenY()-this._pointB.screenY()));                ctx.lineTo(this._pointA.screenX(), this._pointA.screenY()-this._pointA.screenY()+0.9*(this._pointA.screenY()-this._pointB.screenY()));                ctx.moveTo(this._pointA.screenX(), this._pointA.screenY()-this._pointA.screenY()+0.9*(this._pointA.screenY()-this._pointB.screenY()));                ctx.lineTo(this._pointA.screenX(), this._pointA.screenY());                ctx.moveTo(this._pointA.screenX(), this._pointA.screenY());                ctx.stroke();                ctx.fill();            }            ctx.stroke();                        //awh added a small circle of radius = 1/2 width so that where branches meet there is a nice cirve not jagged edges            ctx.closePath();            ctx.beginPath();            ctx.lineWidth  = 1;            ctx.arc(this._pointA.screenX(),this._pointA.screenY(),this._env.width*0.45, 0, Math.PI*2, true);            ctx.fill();            ctx.stroke();        }	},	_getLightFactor:function() {		// generate light factor        if (this.depth()===0){            return 1;        } else {            return Math.abs(1 / this.depth())*100 ;        }        //return 1	},	// get & set vars	points:function() { return [ this._pointA, this._pointB ] },	pointA:function() { return this._pointA; },	pointB:function() { return this._pointB; },	depth:function() { return Math.min(this._pointA.z(),this._pointB.z()); },	color:function(v) { if(v) this._color = v; else return this._color; },});/*############################################################################################################################################### SCENE 3D ###########################################################################*/var Scene3D = Class.extend({	// private vars	_vpx:0, _vpy:0, _cx:0, _cy:0, _cz:0, _dx:0, _dy:0, _dz:0, _ax:0.0, _ay:0.0, _az:0.0,	// constructor	init:function(fr,ctxid,holder,single,full,pW,pH) { // **** AWH added ctxid **** SWP removed padding, added TreeTools		// setup canvas		this._delay = 1000 / fr;		this._width = (!full) ? pW : $(window).width();		this._height = (!full) ? pH : $(window).height();		this._vpx = this._width / 2;		this._vpy = this._height / 2;		this._cx = 0;		this._cy = 0;		this._holder = holder;        // **** AWH changed this from random to assigned		this._id = ctxid;		this._single = single;        // **** AWH removed this, canvas exists		// add to document		//$(this._holder).append("<canvas width='"+this._width+"' height='"+this._height+"' id='"+this._id+"'></canvas>"); //======== uncomment for SWP development ========//        // **** AWH changed this to reflect the new canvas id assignment        // get context		this._ctx = $("#"+this._id)[0].getContext('2d');		// make a toolbox for this scene		this._tools = new TreeTools(this._id);		// window resize on full		if(full) $(window).bind("resize",function() {			__this._width = $(window).width();			__this._height = $(window).height();			__this._vpx = __this._width / 2;			__this._vpy = __this._height / 2;			$("#"+__this._id).attr({ width:__this._width, height:__this._height });			//if(this._single) { this._update(); this._render(); }		});		// hide		$("#"+this._id).hide();		// begin		this._renderables = [];		if(!this._single) this._initializeRendering();		// show		$("#"+this._id).fadeIn("slow");                        /* added all the below besides __this = this to enable keyboard functions */        this._shiftdown = false;        this._ctrldown = false;		var __this = this;        $(window).bind("keydown",function(e) {            if (!e) var e = window.event;            var code = e.keyCode ? e.keyCode : e.which ? e.which : e.charCode;            if(code==16) __this._shiftdown=true;            else if(__this._shiftdown){                if(code==40) __this._dy=__this._dy+20;                else if(code==38) __this._dy=__this._dy-20;                else if(code==37) __this._dx=__this._dx-20;                else if(code==39) __this._dx=__this._dx+20;            } else {                //spin the tree if arrows are being hit                if(code==40) __this._ax=__this._ax-0.005;                else if(code==38) __this._ax=__this._ax+0.005;                else if(code==37) __this._ay=__this._ay-0.005;                else if(code==39) __this._ay=__this._ay+0.005;                                //zoom the tree if bzuttons are being hit                else if(code==65) __this._cz=__this._cz-500.0;                else if(code==90) __this._cz=__this._cz+500.0;                                //spin tree about z if                 else if(code==188) __this._az=__this._az+0.005;                else if(code==190) __this._az=__this._az-0.005;            }            return true;        });        $(window).bind("keyup",function(e) {            if (!e) var e = window.event;            var code = e.keyCode ? e.keyCode : e.which ? e.which : e.charCode;            if(code==16) __this._shiftdown=false;            __this._dy=0; __this._dy=0; __this._dx=0; __this._dx=0; __this._dx=0;        });	},	addToRenderList:function(objs) {		for(obj in objs) {			objs[obj].setVp(this._vpx,this._vpy);			objs[obj].setCp(this._cx,this._cy,this._cz);			objs[obj].ctx(this._ctx);			this._renderables.push(objs[obj]);		}		if(this._single) { this._update(); this._render(); }	},	removeFromRenderList:function(obj) {		this._renderables.splice(this._renderables.indexOf(obj),1);	},	setVp:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;		// set vanishing point on all targets		for(r in this._renderables) this._renderables[r].setVp(this._vpx, this._vpy);	},	setCp:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;		// set center point on all targets		for(r in this._renderables) this._renderables[r].setCp(this._cx, this._cy, this._cz);	},		_initializeRendering:function() {		// define scope for timer		var __this = this;		// begin frame rendering		this._intID = setInterval(__enterFrameHandler,this._delay);		// define timer handler		function __enterFrameHandler() { __this._update(); __this._render(); };	},	_update:function() {		//this._ax = 0.001;		//this._ay = 0.000;		//this._az = 0.000;        //console.log(this._ax);        		//this._az = 0.0005;		//this._osc += this._az;		//this._dy = (1/this._ay)*Math.sin(this._osc);		for(r in this._renderables) {			this._renderables[r].setVp(this._vpx, this._vpy);			this._renderables[r].setCp(this._cx, this._cy, this._cz);			this._renderables[r].update({dx:this._dx, dy:this._dy, dz:this._dz, ax:this._ax, ay:this._ay, az:this._az});		}	},	_render:function() {// Check for mouse up over all scene nodes        // background color can only be set by one of the trees in the renderables        // for now I just grab the first tree and pull the env color        // will work since we are only disp one tree at the mo.        this._ctx.fillStyle = "#"+this._renderables[0]._environment.color;        // also changed this to fillRect not clearRect to add color		this._ctx.globalAlpha = 1;		this._ctx.fillRect(0,0,this._width,this._height);        		this._ctx.lineWidth = 0.5;		this._ctx.lineJoin = "round";		for(r in this._renderables) this._renderables[r].render();		// check for click on nodes		if(this._tools.lastM().x && this._tools.lastM().y) {			var xu = this._tools.lastM().x + this._tools.padding();			var xl = this._tools.lastM().x - this._tools.padding();			var yu = this._tools.lastM().y + this._tools.padding();			var yl = this._tools.lastM().y - this._tools.padding();			for(r in this._renderables) {				for(n in this._renderables[r].nodeList()) {					if(this._renderables[r].nodeList()[n].point3D().screenX()<xu 						&& this._renderables[r].nodeList()[n].point3D().screenX()>xl						&& this._renderables[r].nodeList()[n].point3D().screenY()<yu 						&& this._renderables[r].nodeList()[n].point3D().screenY()>yl					) this._tools.currentTool(this._renderables[r].nodeList()[n],this._renderables[r]);                        				}			}		}		this._tools.lastM().x = null;		this._tools.lastM().y = null;	},	// get & set vars	fr:function(v) {		if(v) {			this._delay = 1000 / v;			clearTimeout(this._intID);			this._initializeRendering();		} else return 1000 / this._delay;	},	vpx:function(v) { if(v) this._vpx = v; else return this._vpx; },	vpy:function(v) { if(v) this._vpy = v; else return this._vpy; },	cx:function(v) { if(v) this._cx = v; else return this._cx; },	cy:function(v) { if(v) this._cy = v; else return this._cy; },	cz:function(v) { if(v) this._cz = v; else return this._cz; },	dx:function(v) { if(v) this._dx = v; else return this._dx; },	dy:function(v) { if(v) this._dy = v; else return this._dy; },	dz:function(v) { if(v) this._dz = v; else return this._dz; },	ax:function(v) { if(v) this._ax = v; else return this._ax; },	ay:function(v) { if(v) this._ay = v; else return this._ay; },	az:function(v) { if(v) this._az = v; else return this._az; },	width:function() { return this._width; },	height:function() { return this._height; }});/*################################################################################################################################################### NODE###########################################################################*/var Node = Class.extend({	// private vars	_numParents:0, _layer:0, _isLeaf:false, _isRoot:false,	// constructor	init:function(id) { this._id = id; this._children = []; this._siblings = []; },	addChild:function(v) { this._children.push(v); },	// get & set vars	id:function() { return this._id; },	children:function() { return this._children; },	siblings:function(v) { if(v) this._siblings = v; else return this._siblings; },	numChildren:function() { return this._children.length; },	numSiblings:function() { return this._siblings.length; },	numParents:function(v) { if(v) this._numParents = v; else return this._numParents; },	layer:function(v) { if(v) this._layer = v; else return this._layer; },	isLeaf:function(v) { if(v) this._isLeaf = v; else return this._isLeaf; },	isRoot:function(v) { if(v) this._isRoot = v; else return this._isRoot; },	color:function(v) { if(v) this._color = v; else return this._color; },	uri:function(v) { if(v) this._uri = v; else return this._uri; },	visibility:function(v) { if(v===undefined) return this._visibility; else this._visibility = v; },	//–––––––––––––––––––––– for drawing ––––––––––––––––––––––//	// private vars -- none	point3D:function(v) { if(v) this._point3D = v; else return this._point3D; }});/*################################################################################################################################################### TREE ###########################################################################*/var Tree = Class.extend({	// private vars -- dynamic	// constructor	init:function(json) {		// store original data		this._json = json;		// nest this tree around the root		this.nest(this._json.root);        this.title = this._json.title;        		var __this = this;                //Title input and change        $('#ProjectTitle').change(function(){            __this.title = $(this).val();        });	},	_nest:function(rootId) {		// define the root node		if(!rootId) rootId = this._flat[0].id;		// get the root json object		var root = $.lookUp(this._flat,"id",rootId);		// exit if invalid		if(!root) { console.log("invalid tree root id"); return false; }		// ensure proper tree direction		if(root.parent_id) {			// if root is leaf, root's parent becomes root			if(!root.children) root = $.lookUp(this._flat,"id",root.parent_id);			// parent -> child			root.children.push({ "id":root.parent_id });			// child -> parent			var parent = $.lookUp(this._flat,"id",root.parent_id);			for(c in parent.children) if(parent.children[c].id==root.id) delete parent.children[c];			// rename parents			root.parent_id = null;			parent.parent_id = root.id;		}		// make the tree		this._numLeaves = 0;		this._numLayers = 0;		this._nodeList = [];		this._nodes = new Node(rootId);		this._nodes.isRoot(true);		this._branch(this._nodes,root);		for(n in this._nodeList) {			// assign layers			if(this._nodeList[n].isLeaf()) this._nodeList[n].layer(this._numLayers-1);			else this._nodeList[n].layer(this._nodeList[n].numParents());			// assign siblings			for(c in this._nodeList[n].children()) {				var s = this._nodeList[n].children().slice(0);				s.splice(s.indexOf(s[c]),1);				this._nodeList[n].children()[c].siblings(s);			}		}	},	_branch:function(n,d) {		// ensure proper tree direction		for(c in d.children) {			var cd = $.lookUp(this._flat,"id",d.children[c].id);			if(cd.parent_id && cd.parent_id!=d.id) {				// parent -> child				cd.children.push({ "id":cd.parent_id });				// child -> parent				var cpd = $.lookUp(this._flat,"id",cd.parent_id);				for(cc in cpd.children) if(cpd.children[cc].id==cd.id) delete cpd.children[cc];				// rename parents				cd.parent_id = d.id;				cpd.parent_id = cd.id;			}		}        //awh, not sure if logical place, but adds some extra variables to the node        n.color(d.color);        n.visibility(d.visibility);        n.uri(d.uri);        		// move down tree		if(!d.children) {			n.isLeaf(true);			this._numLeaves++;		} else for(c in d.children) {			var cn = new Node(d.children[c].id);			n.addChild(cn);			//cn.parent(n);			cn.numParents(n.numParents()+1);			this._branch(cn,$.lookUp(this._flat,"id",cn.id()));		}		// max number parents = tree's layer count		if(this._numLayers<=n.numParents()) this._numLayers = n.numParents()+1;		// collect node ref for list		this._nodeList.push(n);	},	nest:function(v) { // Adds EnvTools which gets overwritten on each nest().		// clear from scene		if(this._scene) this._scene.removeFromRenderList(this);		// clone the original data		this._clone = $.extend(true,{},this._json);		// define usable objects		this._flat = this._clone.tree;		this._environment = this._clone.environment;		// make env tools		this._tools = new EnvTools(this._environment);		// re-nest		this._nest(v); 	},	// get & set vars	nodes:function() { return this._nodes; },	nodeList:function() { return this._nodeList; },	numLayers:function(v) { if(v) this._numLayers = v; else return this._numLayers; },	//–––––––––––––––––––––– for drawing ––––––––––––––––––––––//	// private vars	plot:function(type) {		// refresh data		this._l = [];		this._d = [];		// parse on layer		var nls = [];		for(i=0;i<this._numLayers;i++) nls.push([]);		for(n in this._nodeList) nls[this._nodeList[n].layer()].push(this._nodeList[n]);		nls.reverse();		// calculate coordinates		switch(type) {			case "dendrogram" : default :				var gap_x = this._scene.width() / (this._numLayers - 1);				var gap_y = this._scene.height() / (this._numLeaves - 1);				this._max_z = (this._numLayers - 1) * gap_x;				var j = 0;				for(l in nls) {					// sort leaf order					//if(l==this._numLayers-1) { nls[l].sort(function(a,b) { return a.numParents() - b.numParents(); }); }					for(n in nls[l]) {						var x = (nls[l][n].layer() * gap_x) - this._scene.vpx();						if(nls[l][n].isLeaf()) {							var y = (j * gap_y) - this._scene.vpy(); j++;						} else {							//nls[l][n].children().sort(function(a,b) { return b.point3D().y() - a.point3D().y(); });							var max_y = nls[l][n].children()[0].point3D().y();							var min_y = nls[l][n].children()[nls[l][n].numChildren()-1].point3D().y();							var y = min_y + ((max_y - min_y) / 2);						}						var z = (nls[l][n].numParents() * gap_x) - (this._max_z / 2);                        nls[l][n].point3D(new Point3D(x,y,z));					}				}				break;			case "circular dendrogram" :				var gap_r = Math.min(this._scene.width(),this._scene.height()) / (this._numLayers - 1) / 2;				var gap_t = 2*Math.PI / (this._numLeaves - 1);				this._max_z = (this._numLayers - 1) * gap_r;				var j = 0;				for(l in nls) {					// sort leaf order					//if(l==this._numLayers-1) { 						//nls[l].sort(function(a,b) { return b.numParents() - a.numParents(); }); 					//}					for(n in nls[l]) {						var r = nls[l][n].layer() * gap_r;						if(nls[l][n].isLeaf()) {							var t = (j * gap_t); j++;							var y = (r * Math.sin(t));						} else {							//nls[l][n].children().sort(function(a,b) { return b.point3D().t() - a.point3D().t(); });							var max_t = nls[l][n].children()[0].point3D().t();							var min_t = nls[l][n].children()[nls[l][n].numChildren()-1].point3D().t();							var t = min_t + ((max_t - min_t) / 2);							var y = (r * Math.sin(t));							console.log(180*min_t/Math.PI,180*max_t/Math.PI);						}						var x = (r * Math.cos(t));						var z = (nls[l][n].numParents() * gap_r) - (this._max_z / 2);						//console.log(r,t,x,y);						nls[l][n].point3D(new Point3D(x,y,z));					}				}				break;				}		// make dots		//for(n in this._nodeList) this._d.push(new Dot(this._nodeList[n].point3D(),this._environment));		for(n in this._nodeList) this._d.push(new Dot(this._nodeList[n].point3D(),this._nodeList[n],this._environment));		// make lines		this._connect(this._nodes);		// display		this._viz();	},	_connect:function(node) {        for(c in node.children()) {            //this._l.push(new Line(node.point3D(),node.children()[c].point3D(),this._environment));            this._l.push(new Line(node.point3D(),node.children()[c].point3D(),node.children()[c],this._environment));            this._connect(node.children()[c]);        }	},	_viz:function() {		//this._local = {dx:0,dy:0,dz:0,ax:0,ay:0,az:0};		this._local = {dx: this._environment.offset.dx,                       dy: this._environment.offset.dy,                       dz: this._environment.offset.dz,                       ax: this._environment.offset.ax,                       ay: this._environment.offset.ay,                       az: this._environment.offset.az};        console.log(this._environment);		//this._local = {dx:0,dy:0,dz:0,ax:-Math.PI / 2,ay:Math.PI / 4,az:0};		this._color = [ 255,255,255 ];		// set color                //awh removed these so that color can be incorporated by the node directly		//for(d in this._d) this._d[d].color(this._color);		//for(l in this._l) this._l[l].color(this._color);        		// make local update if present		if(!$.isEmpty(this._local)) this.update(this._local);		// add to scene		this._scene.addToRenderList([this]);		// zoom		this._scene.setCp(this._scene.cx(),this._scene.cy(),this._max_z*2);	},	update:function(v) {		for(d in this._d) {		 	this._d[d].pointA().x(this._d[d].pointA().x()+v.dx);		 	this._d[d].pointA().y(this._d[d].pointA().y()+v.dy);		 	this._d[d].pointA().z(this._d[d].pointA().z()+v.dz);		 	this._d[d].pointA().rotateX(v.ax);		 	this._d[d].pointA().rotateY(v.ay);		 	this._d[d].pointA().rotateZ(v.az);		}	},	render:function() {		for(d in this._d) this._d[d].draw(this._ctx);		for(l in this._l) this._l[l].draw(this._ctx);	},	setVp:function(vpx,vpy) {		this._vpx = vpx;		this._vpy = vpy;		// set points vanishing point		for(d in this._d) this._d[d].pointA().setVanishingPoint(this._vpx,this._vpy);	},	setCp:function(cx,cy,cz) {		this._cx = cx;		this._cy = cy;		this._cz = cz;		// set points center point		for(d in this._d) this._d[d].pointA().setCenter(this._cx,this._cy,this._cz);	},	depth:function() {		var d = new Array();		for(l in this._l) d.push(this._l[l].depth());		return $.arrayMin(d);	},	// get & set vars	scene:function(v) { if(v) this._scene = v; else return this._scene; },	ctx:function(v) { if(v) this._ctx = v; else return this._ctx; },	//–––––––––––––––––––––– for tools ––––––––––––––––––––––//});//************ Statc Properties ************//Tree.DENDROGRAM = "dendrogram";Tree.CIRC_DENDROGRAM = "circular dendrogram";/*############################################################################################################################################## DOC READY  ###########################################################################*/function InitDraw() {	//–––––––––––––––––––––––––––––––––––––––––––––––––––––––––– EXTEND UTILS	// on core classes	// ...	// on jquery	$.extend({		lookUp:function(o,p,v) {			// returns false if not unique !			var r; var n = 0;			for(i in o) if(o[i][p]==v) { r = o[i]; n++; }			return (n!=1) ? false : r;		},		makeId:function(l) {		    var text = "";		    var possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";		    for(i=0; i<l; i++) text += possible.charAt(Math.floor(Math.random()*possible.length));		    return text;		},		isEmpty:function(o) {			var e = true;			for(a in o) e = false;			return e;		},		arrayMin:function(a) {			var min = a[0];			var len = a.length;			for (i=1; i<len; i++) if(a[i]<min) min = a[i];			return min;		},	});	// on jquery objects	$.fn.extend({ });	//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DOC SETUP	// define console to avoid errors when it isn't available	if(!window.console) window.console = { log:function() {} };	//––––––––––––––––––––––––––––––––––––––––––––––––––––––––––– DOC METHODS	// ...	//–––––––––––––––––––––––––––––––––––––––––––––––––––––––––– INIT OBJECTS	/* get some data if present	$.ajax({		type:"GET",		url:"http://phylobox.appspot.com/api/lookup",		data:"k=tmp-phylobox-1-0-93764e1e-00ba-4c3d-9911-10b2b07ddb64",		//dataType:"json",		complete:function(request) { },		success:function(json) { console.log(json); },		error:function(e) { console.log(e.responseText); }	});*/	// make the scene	var scene = new Scene3D(12,"tree-canvas","body",false,true);	// make a tree	var tree = new Tree(phylojson);	//var tree = new Tree(amphibian.tree,amphibian.root);	//var tree = new Tree(unknown.tree,unknown.root);	var r = phylojson.root;	tree.scene(scene);	tree.plot(Tree.DENDROGRAM);	}//####################################################################### END//$(function() { InitDraw(); }); //======== uncomment for SWP development ========//